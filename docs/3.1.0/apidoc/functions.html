
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Functions &mdash; QuTiP 3.1.0 Documentation</title>
    
    <link rel="stylesheet" href="../static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../static/bootswatch-3.2.0/flatly/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../static/site.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../static/bootstrap-3.2.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../static/favicon.ico"/>
    <link rel="top" title="QuTiP 3.1.0 Documentation" href="../index.html" />
    <link rel="up" title="API documentation" href="apidoc.html" />
    <link rel="next" title="Change Log" href="../changelog.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          QuTiP</a>
        <span class="navbar-text navbar-version pull-left"><b>3.1.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="http://qutip.org">qutip.org</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Docs <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../frontmatter.html">Frontmatter</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../frontmatter.html#about-this-documentation">About This Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frontmatter.html#citing-this-project">Citing This Project</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frontmatter.html#funding">Funding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frontmatter.html#about-qutip">About QuTiP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frontmatter.html#contributing-to-qutip">Contributing to QuTiP</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#general-requirements">General Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#platform-independent-installation">Platform-independent installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#get-the-source-code">Get the source code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#installing-from-source">Installing from source</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#installation-on-ubuntu-linux">Installation on Ubuntu Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#installation-on-mac-os-x-10-8">Installation on Mac OS X (10.8+)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#installation-on-windows">Installation on Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#optional-installation-options">Optional Installation Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#verifying-the-installation">Verifying the Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#checking-version-information-using-the-about-function">Checking Version Information using the About Function</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../guide/guide.html">Users Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-overview.html">Guide Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-basics.html">Basic Operations on Quantum Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-states.html">Manipulating States and Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-tensor.html">Using Tensor Products and Partial Traces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-dynamics.html">Time Evolution and Quantum System Dynamics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-steady.html">Solving for Steady-State Solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-eseries.html">An Overview of the Eseries Class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-correlation.html">Two-time correlation functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-bloch.html">Plotting on the Bloch Sphere</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-visualization.html">Visualization of quantum states and processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-parfor.html">Parallel computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-saving.html">Saving QuTiP Objects and Data Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-random.html">Generating Random Quantum States &amp; Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-settings.html">Modifying Internal QuTiP Settings</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="apidoc.html">API documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Change Log</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-3-1-0-january-1-2015">Version 3.1.0 (January 1, 2015):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-3-0-1-aug-5-2014">Version 3.0.1 (Aug 5, 2014):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-3-0-0-july-17-2014">Version 3.0.0 (July 17, 2014):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-2-2-0-march-01-2013">Version 2.2.0 (March 01, 2013):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-2-1-0-october-05-2012">Version 2.1.0 (October 05, 2012):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-2-0-0-june-01-2012">Version 2.0.0 (June 01, 2012):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-1-1-4-may-28-2012">Version 1.1.4 (May 28, 2012):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-1-1-3-november-21-2011">Version 1.1.3 (November 21, 2011):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-1-1-2-october-27-2011">Version 1.1.2 (October 27, 2011)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-1-1-1-october-25-2011">Version 1.1.1 (October 25, 2011)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-1-1-0-october-04-2011">Version 1.1.0 (October 04, 2011)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-1-0-0-july-29-2011">Version 1.0.0 (July 29, 2011)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Developers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../contributors.html#lead-developers">Lead Developers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributors.html#contributors">Contributors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../biblio.html">Bibliography</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Functions</a><ul>
<li><a class="reference internal" href="#manipulation-and-creation-of-states-and-operators">Manipulation and Creation of States and Operators</a><ul>
<li><a class="reference internal" href="#module-qutip.states">Quantum States</a></li>
<li><a class="reference internal" href="#module-qutip.operators">Quantum Operators</a></li>
<li><a class="reference internal" href="#module-qutip.random_objects">Random Operators and States</a></li>
<li><a class="reference internal" href="#module-qutip.three_level_atom">Three-Level Atoms</a><ul>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#notes">Notes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-qutip.superoperator">Superoperators and Liouvillians</a></li>
<li><a class="reference internal" href="#module-qutip.superop_reps">Superoperator Representations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#functions-acting-on-states-and-operators">Functions acting on states and operators</a><ul>
<li><a class="reference internal" href="#module-qutip.tensor">Tensor</a></li>
<li><a class="reference internal" href="#module-qutip.expect">Expectation Values</a></li>
<li><a class="reference internal" href="#module-qutip.partial_transpose">Partial Transpose</a></li>
<li><a class="reference internal" href="#module-qutip.entropy">Entropy Functions</a></li>
<li><a class="reference internal" href="#module-qutip.metrics">Density Matrix Metrics</a></li>
<li><a class="reference internal" href="#module-qutip.continuous_variables">Continous Variables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dynamics-and-time-evolution">Dynamics and Time-Evolution</a><ul>
<li><a class="reference internal" href="#module-qutip.sesolve">Schrödinger Equation</a></li>
<li><a class="reference internal" href="#module-qutip.mesolve">Master Equation</a></li>
<li><a class="reference internal" href="#module-qutip.mcsolve">Monte Carlo Evolution</a></li>
<li><a class="reference internal" href="#module-qutip.essolve">Exponential Series</a></li>
<li><a class="reference internal" href="#module-qutip.bloch_redfield">Bloch-Redfield Master Equation</a></li>
<li><a class="reference internal" href="#module-qutip.floquet">Floquet States and Floquet-Markov Master Equation</a></li>
<li><a class="reference internal" href="#module-qutip.stochastic">Stochastic Schrödinger Equation and Master Equation</a></li>
<li><a class="reference internal" href="#module-qutip.correlation">Correlation Functions</a></li>
<li><a class="reference internal" href="#module-qutip.steadystate">Steady-state Solvers</a></li>
<li><a class="reference internal" href="#module-qutip.propagator">Propagators</a></li>
<li><a class="reference internal" href="#module-qutip">Time-dependent problems</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visualization">Visualization</a><ul>
<li><a class="reference internal" href="#module-qutip.wigner">Pseudoprobability Functions</a></li>
<li><a class="reference internal" href="#graphs-and-visualization">Graphs and Visualization</a></li>
<li><a class="reference internal" href="#module-qutip.tomography">Quantum Process Tomography</a></li>
</ul>
</li>
<li><a class="reference internal" href="#quantum-information-processing">Quantum Information Processing</a><ul>
<li><a class="reference internal" href="#module-qutip.qip.gates">Gates</a></li>
<li><a class="reference internal" href="#module-qutip.qip.qubits">Qubits</a></li>
<li><a class="reference internal" href="#module-qutip.qip.algorithms.qft">Algorithms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-qutip.control.grape">Optimal control</a></li>
<li><a class="reference internal" href="#utilitiy-functions">Utilitiy Functions</a><ul>
<li><a class="reference internal" href="#module-qutip.graph">Graph Theory Routines</a></li>
<li><a class="reference internal" href="#module-qutip.utilities">Utility Functions</a></li>
<li><a class="reference internal" href="#module-qutip.fileio">File I/O Functions</a></li>
<li><a class="reference internal" href="#module-qutip.parallel">Parallelization</a></li>
<li><a class="reference internal" href="#module-qutip.ipynbtools">IPython Notebook Tools</a></li>
<li><a class="reference internal" href="#module-qutip">Miscellaneous</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="../changelog.html" title="Next Chapter: Change Log"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Change Log &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="functions">
<span id="id1"></span><h1>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="manipulation-and-creation-of-states-and-operators">
<h2>Manipulation and Creation of States and Operators<a class="headerlink" href="#manipulation-and-creation-of-states-and-operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.states">
<span id="quantum-states"></span><h3>Quantum States<a class="headerlink" href="#module-qutip.states" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.states.basis">
<tt class="descname">basis</tt><big>(</big><em>N</em>, <em>n=0</em>, <em>offset=0</em><big>)</big><a class="reference internal" href="../modules/qutip/states.html#basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the vector representation of a Fock state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of Fock states in Hilbert space.</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p>Integer corresponding to desired number state, defaults
to 0 if omitted.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the state.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote class="last">
<div><p>Qobj representing the requested number state <tt class="docutils literal"><span class="pre">|n&gt;</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>A subtle incompatibility with the quantum optics toolbox: In QuTiP:</p>
<div class="highlight-python"><div class="highlight"><pre>basis(N, 0) = ground state
</pre></div>
</div>
<p>but in the qotoolbox:</p>
<div class="highlight-python"><div class="highlight"><pre>basis(N, 1) = ground state
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 1.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.coherent">
<tt class="descname">coherent</tt><big>(</big><em>N</em>, <em>alpha</em>, <em>offset=0</em>, <em>method='operator'</em><big>)</big><a class="reference internal" href="../modules/qutip/states.html#coherent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.coherent" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a coherent state with eigenvalue alpha.</p>
<p>Constructed using displacement operator on vacuum state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of Fock states in Hilbert space.</p>
</div></blockquote>
<p><strong>alpha</strong> : float/complex</p>
<blockquote>
<div><p>Eigenvalue of coherent state.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the state. Using a non-zero offset will make the
default method &#8216;analytic&#8217;.</p>
</div></blockquote>
<p><strong>method</strong> : string {&#8216;operator&#8217;, &#8216;analytic&#8217;}</p>
<blockquote>
<div><p>Method for generating coherent state.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote class="last">
<div><p>Qobj quantum object for coherent state</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Select method &#8216;operator&#8217; (default) or &#8216;analytic&#8217;. With the
&#8216;operator&#8217; method, the coherent state is generated by displacing
the vacuum state using the displacement operator defined in the
truncated Hilbert space of size &#8216;N&#8217;. This method guarantees that the
resulting state is normalized. With &#8216;analytic&#8217; method the coherent state
is generated using the analytical formula for the coherent state
coefficients in the Fock basis. This method does not guarantee that the
state is normalized if truncated to a small number of Fock states,
but would in that case give more accurate coefficients.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coherent</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mf">0.25j</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[  9.69233235e-01+0.j        ]</span>
<span class="go"> [  0.00000000e+00+0.24230831j]</span>
<span class="go"> [ -4.28344935e-02+0.j        ]</span>
<span class="go"> [  0.00000000e+00-0.00618204j]</span>
<span class="go"> [  7.80904967e-04+0.j        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.coherent_dm">
<tt class="descname">coherent_dm</tt><big>(</big><em>N</em>, <em>alpha</em>, <em>offset=0</em>, <em>method='operator'</em><big>)</big><a class="reference internal" href="../modules/qutip/states.html#coherent_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.coherent_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix representation of a coherent state.</p>
<p>Constructed via outer product of <a class="reference internal" href="#qutip.states.coherent" title="qutip.states.coherent"><tt class="xref py py-func docutils literal"><span class="pre">qutip.states.coherent</span></tt></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of Fock states in Hilbert space.</p>
</div></blockquote>
<p><strong>alpha</strong> : float/complex</p>
<blockquote>
<div><p>Eigenvalue for coherent state.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the state.</p>
</div></blockquote>
<p><strong>method</strong> : string {&#8216;operator&#8217;, &#8216;analytic&#8217;}</p>
<blockquote>
<div><p>Method for generating coherent density matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote class="last">
<div><p>Density matrix representation of coherent state.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Select method &#8216;operator&#8217; (default) or &#8216;analytic&#8217;. With the
&#8216;operator&#8217; method, the coherent density matrix is generated by displacing
the vacuum state using the displacement operator defined in the
truncated Hilbert space of size &#8216;N&#8217;. This method guarantees that the
resulting density matrix is normalized. With &#8216;analytic&#8217; method the coherent
density matrix is generated using the analytical formula for the coherent
state coefficients in the Fock basis. This method does not guarantee that
the state is normalized if truncated to a small number of Fock states,
but would in that case give more accurate coefficients.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.25j</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.93941695+0.j          0.00000000-0.23480733j -0.04216943+0.j        ]</span>
<span class="go"> [ 0.00000000+0.23480733j  0.05869011+0.j          0.00000000-0.01054025j]</span>
<span class="go"> [-0.04216943+0.j          0.00000000+0.01054025j  0.00189294+0.j        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.fock">
<tt class="descname">fock</tt><big>(</big><em>N</em>, <em>n=0</em>, <em>offset=0</em><big>)</big><a class="reference internal" href="../modules/qutip/states.html#fock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bosonic Fock (number) state.</p>
<p>Same as <a class="reference internal" href="#qutip.states.basis" title="qutip.states.basis"><tt class="xref py py-func docutils literal"><span class="pre">qutip.states.basis</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of states in the Hilbert space.</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">int</span></tt> for desired number state, defaults to 0 if omitted.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Requested number state <span class="math">\(\left|n\right&gt;\)</span>.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fock</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [1]], shape = [4, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.fock_dm">
<tt class="descname">fock_dm</tt><big>(</big><em>N</em>, <em>n=0</em>, <em>offset=0</em><big>)</big><a class="reference internal" href="../modules/qutip/states.html#fock_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.fock_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix representation of a Fock state</p>
<p>Constructed via outer product of <a class="reference internal" href="#qutip.states.fock" title="qutip.states.fock"><tt class="xref py py-func docutils literal"><span class="pre">qutip.states.fock</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of Fock states in Hilbert space.</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">int</span></tt> for desired number state, defaults to 0 if omitted.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote class="last">
<div><p>Density matrix representation of Fock state.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.ket2dm">
<tt class="descname">ket2dm</tt><big>(</big><em>Q</em><big>)</big><a class="reference internal" href="../modules/qutip/states.html#ket2dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.ket2dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes input ket or bra vector and returns density matrix
formed by outer product.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Q</strong> : qobj</p>
<blockquote>
<div><p>Ket or bra type quantum object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote class="last">
<div><p>Density matrix formed by outer product of <cite>Q</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2dm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.qutrit_basis">
<tt class="descname">qutrit_basis</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/qutip/states.html#qutrit_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.qutrit_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis states for a three level system (qutrit)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>qstates</strong> : array</p>
<blockquote class="last">
<div><p>Array of qutrit basis vectors</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.thermal_dm">
<tt class="descname">thermal_dm</tt><big>(</big><em>N</em>, <em>n</em>, <em>method='operator'</em><big>)</big><a class="reference internal" href="../modules/qutip/states.html#thermal_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.thermal_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix for a thermal state of n particles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of basis states in Hilbert space.</p>
</div></blockquote>
<p><strong>n</strong> : float</p>
<blockquote>
<div><p>Expectation value for number of particles in thermal state.</p>
</div></blockquote>
<p><strong>method</strong> : string {&#8216;operator&#8217;, &#8216;analytic&#8217;}</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">string</span></tt> that sets the method used to generate the
thermal state probabilities</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote class="last">
<div><p>Thermal state density matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The &#8216;operator&#8217; method (default) generates
the thermal state using the truncated number operator <tt class="docutils literal"><span class="pre">num(N)</span></tt>. This
is the method that should be used in computations. The
&#8216;analytic&#8217; method uses the analytic coefficients derived in
an infinite Hilbert space. The analytic form is not necessarily normalized,
if truncated too aggressively.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">thermal_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.51612903  0.          0.          0.          0.        ]</span>
<span class="go"> [ 0.          0.25806452  0.          0.          0.        ]</span>
<span class="go"> [ 0.          0.          0.12903226  0.          0.        ]</span>
<span class="go"> [ 0.          0.          0.          0.06451613  0.        ]</span>
<span class="go"> [ 0.          0.          0.          0.          0.03225806]]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">thermal_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;analytic&#39;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.5      0.       0.       0.       0.     ]</span>
<span class="go"> [ 0.       0.25     0.       0.       0.     ]</span>
<span class="go"> [ 0.       0.       0.125    0.       0.     ]</span>
<span class="go"> [ 0.       0.       0.       0.0625   0.     ]</span>
<span class="go"> [ 0.       0.       0.       0.       0.03125]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.phase_basis">
<tt class="descname">phase_basis</tt><big>(</big><em>N</em>, <em>m</em>, <em>phi0=0</em><big>)</big><a class="reference internal" href="../modules/qutip/states.html#phase_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.phase_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis vector for the mth phase of the Pegg-Barnett phase operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of basis vectors in Hilbert space.</p>
</div></blockquote>
<p><strong>m</strong> : int</p>
<blockquote>
<div><p>Integer corresponding to the mth discrete phase phi_m=phi0+2*pi*m/N</p>
</div></blockquote>
<p><strong>phi0</strong> : float (default=0)</p>
<blockquote>
<div><p>Reference phase angle.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote class="last">
<div><p>Ket vector for mth Pegg-Barnett phase operator basis state.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Pegg-Barnett basis states form a complete set over the truncated
Hilbert space.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_number_enumerate">
<tt class="descname">state_number_enumerate</tt><big>(</big><em>dims</em>, <em>excitations=None</em>, <em>state=None</em>, <em>idx=0</em><big>)</big><a class="reference internal" href="../modules/qutip/states.html#state_number_enumerate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_number_enumerate" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator that enumerate all the state number arrays (quantum numbers on
the form [n1, n2, n3, ...]) for a system with dimensions given by dims.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">state_number_enumerate</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="go">[ 0.  0.]</span>
<span class="go">[ 0.  1.]</span>
<span class="go">[ 1.  0.]</span>
<span class="go">[ 1.  1.]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list or array</p>
<blockquote>
<div><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</div></blockquote>
<p><strong>state</strong> : list</p>
<blockquote>
<div><p>Current state in the iteration. Used internally.</p>
</div></blockquote>
<p><strong>excitations</strong> : integer (None)</p>
<blockquote>
<div><p>Restrict state space to states with excitation numbers below or
equal to this value.</p>
</div></blockquote>
<p><strong>idx</strong> : integer</p>
<blockquote>
<div><p>Current index in the iteration. Used internally.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state_number</strong> : list</p>
<blockquote class="last">
<div><p>Successive state number arrays that can be used in loops and other
iterations, using standard state enumeration <em>by definition</em>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_number_index">
<tt class="descname">state_number_index</tt><big>(</big><em>dims</em>, <em>state</em><big>)</big><a class="reference internal" href="../modules/qutip/states.html#state_number_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_number_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of a quantum state corresponding to state,
given a system with dimensions given by dims.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">state_number_index</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">6.0</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list or array</p>
<blockquote>
<div><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</div></blockquote>
<p><strong>state</strong> : list</p>
<blockquote>
<div><p>State number array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>idx</strong> : list</p>
<blockquote class="last">
<div><p>The index of the state given by <cite>state</cite> in standard enumeration
ordering.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_index_number">
<tt class="descname">state_index_number</tt><big>(</big><em>dims</em>, <em>index</em><big>)</big><a class="reference internal" href="../modules/qutip/states.html#state_index_number"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_index_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a quantum number representation given a state index, for a system
of composite structure defined by dims.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">state_index_number</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">[1, 1, 0]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list or array</p>
<blockquote>
<div><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</div></blockquote>
<p><strong>index</strong> : integer</p>
<blockquote>
<div><p>The index of the state in standard enumeration ordering.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : list</p>
<blockquote class="last">
<div><p>The state number array corresponding to index <cite>index</cite> in standard
enumeration ordering.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_number_qobj">
<tt class="descname">state_number_qobj</tt><big>(</big><em>dims</em>, <em>state</em><big>)</big><a class="reference internal" href="../modules/qutip/states.html#state_number_qobj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_number_qobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Qobj representation of a quantum state specified by the state
array <cite>state</cite>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">state_number_qobj</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list or array</p>
<blockquote>
<div><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</div></blockquote>
<p><strong>state</strong> : list</p>
<blockquote>
<div><p>State number array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj.qobj</span></tt></p>
<blockquote class="last">
<div><p>The state as a <tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj.qobj</span></tt> instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.enr_state_dictionaries">
<tt class="descname">enr_state_dictionaries</tt><big>(</big><em>dims</em>, <em>excitations</em><big>)</big><a class="reference internal" href="../modules/qutip/states.html#enr_state_dictionaries"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.enr_state_dictionaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of states, and lookup-dictionaries for translating
a state tuple to a state index, and vice versa, for a system with a given
number of components and maximum number of excitations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims: list</strong></p>
<blockquote>
<div><p>A list with the number of states in each sub-system.</p>
</div></blockquote>
<p><strong>excitations</strong> : integer</p>
<blockquote>
<div><p>The maximum numbers of dimension</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">nstates, state2idx, idx2state: integer, dict, dict</p>
<blockquote class="last">
<div><p>The number of states <cite>nstates</cite>, a dictionary for looking up state
indices from a state tuple, and a dictionary for looking up state
state tuples from state indices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.enr_thermal_dm">
<tt class="descname">enr_thermal_dm</tt><big>(</big><em>dims</em>, <em>excitations</em>, <em>n</em><big>)</big><a class="reference internal" href="../modules/qutip/states.html#enr_thermal_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.enr_thermal_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the density operator for a thermal state in the excitation-number-
restricted state space defined by the <cite>dims</cite> and <cite>exciations</cite> arguments.
See the documentation for enr_fock for a more detailed description of
these arguments. The temperature of each mode in dims is specified by
the average number of excitatons <cite>n</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list</p>
<blockquote>
<div><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</div></blockquote>
<p><strong>excitations</strong> : integer</p>
<blockquote>
<div><p>The maximum number of excitations that are to be included in the
state space.</p>
</div></blockquote>
<p><strong>n</strong> : integer</p>
<blockquote>
<div><p>The average number of exciations in the thermal state. <cite>n</cite> can be
a float (which then applies to each mode), or a list/array of the same
length as dims, in which each element corresponds specifies the
temperature of the corresponding mode.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : Qobj</p>
<blockquote class="last">
<div><p>Thermal state density matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.enr_fock">
<tt class="descname">enr_fock</tt><big>(</big><em>dims</em>, <em>excitations</em>, <em>state</em><big>)</big><a class="reference internal" href="../modules/qutip/states.html#enr_fock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.enr_fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the Fock state representation in a excitation-number restricted
state space. The <cite>dims</cite> argument is a list of integers that define the
number of quantums states of each component of a composite quantum system,
and the <cite>excitations</cite> specifies the maximum number of excitations for
the basis states that are to be included in the state space. The <cite>state</cite>
argument is a tuple of integers that specifies the state (in the number
basis representation) for which to generate the Fock state representation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list</p>
<blockquote>
<div><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</div></blockquote>
<p><strong>excitations</strong> : integer</p>
<blockquote>
<div><p>The maximum number of excitations that are to be included in the
state space.</p>
</div></blockquote>
<p><strong>state</strong> : list of integers</p>
<blockquote>
<div><p>The state in the number basis representation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ket</strong> : Qobj</p>
<blockquote class="last">
<div><p>A Qobj instance that represent a Fock state in the exication-number-
restricted state space defined by <cite>dims</cite> and <cite>exciations</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.operators">
<span id="quantum-operators"></span><h3>Quantum Operators<a class="headerlink" href="#module-qutip.operators" title="Permalink to this headline">¶</a></h3>
<p>This module contains functions for generating Qobj representation of a variety
of commonly occuring quantum operators.</p>
<dl class="function">
<dt id="qutip.operators.create">
<tt class="descname">create</tt><big>(</big><em>N</em>, <em>offset=0</em><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation (raising) operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of Hilbert space.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote>
<div><p>Qobj for raising operator.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote class="last">
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">create</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 1.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  1.41421356+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  1.73205081+0.j  0.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.destroy">
<tt class="descname">destroy</tt><big>(</big><em>N</em>, <em>offset=0</em><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#destroy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Destruction (lowering) operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of Hilbert space.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Qobj for lowering operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">destroy</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.00000000+0.j  1.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  1.41421356+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  1.73205081+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.displace">
<tt class="descname">displace</tt><big>(</big><em>N</em>, <em>alpha</em>, <em>offset=0</em><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#displace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.displace" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode displacement operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of Hilbert space.</p>
</div></blockquote>
<p><strong>alpha</strong> : float/complex</p>
<blockquote>
<div><p>Displacement amplitude.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Displacement operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">displace</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mf">0.25</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.96923323+0.j -0.24230859+0.j  0.04282883+0.j -0.00626025+0.j]</span>
<span class="go"> [ 0.24230859+0.j  0.90866411+0.j -0.33183303+0.j  0.07418172+0.j]</span>
<span class="go"> [ 0.04282883+0.j  0.33183303+0.j  0.84809499+0.j -0.41083747+0.j]</span>
<span class="go"> [ 0.00626025+0.j  0.07418172+0.j  0.41083747+0.j  0.90866411+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.jmat">
<tt class="descname">jmat</tt><big>(</big><em>j</em>, <em>*args</em><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#jmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.jmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Higher-order spin operators:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>j</strong> : float</p>
<blockquote>
<div><p>Spin of operator</p>
</div></blockquote>
<p><strong>args</strong> : str</p>
<blockquote>
<div><p>Which operator to return &#8216;x&#8217;,&#8217;y&#8217;,&#8217;z&#8217;,&#8217;+&#8217;,&#8217;-&#8216;.
If no args given, then output is [&#8216;x&#8217;,&#8217;y&#8217;,&#8217;z&#8217;]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>jmat</strong> : qobj/list</p>
<blockquote class="last">
<div><p><tt class="docutils literal"><span class="pre">qobj</span></tt> for requested spin operator(s).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If no &#8216;args&#8217; input, then returns array of [&#8216;x&#8217;,&#8217;y&#8217;,&#8217;z&#8217;] operators.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">jmat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.          0.70710678  0.        ]</span>
<span class="go"> [ 0.70710678  0.          0.70710678]</span>
<span class="go"> [ 0.          0.70710678  0.        ]]</span>
<span class="go"> Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j          0.+0.70710678j  0.+0.j        ]</span>
<span class="go"> [ 0.-0.70710678j  0.+0.j          0.+0.70710678j]</span>
<span class="go"> [ 0.+0.j          0.-0.70710678j  0.+0.j        ]]</span>
<span class="go"> Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  0.  0.]</span>
<span class="go"> [ 0.  0. -1.]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.num">
<tt class="descname">num</tt><big>(</big><em>N</em>, <em>offset=0</em><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#num"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.num" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object for number operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>The dimension of the Hilbert space.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">oper: qobj</p>
<blockquote class="last">
<div><p>Qobj for number operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">num</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[0 0 0 0]</span>
<span class="go"> [0 1 0 0]</span>
<span class="go"> [0 0 2 0]</span>
<span class="go"> [0 0 0 3]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qeye">
<tt class="descname">qeye</tt><big>(</big><em>N</em><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#qeye"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.qeye" title="Permalink to this definition">¶</a></dt>
<dd><p>Identity operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int or list of ints</p>
<blockquote>
<div><p>Dimension of Hilbert space. If provided as a list of ints,
then the dimension is the product over this list, but the
<tt class="docutils literal"><span class="pre">dims</span></tt> property of the new Qobj are set to this list.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Identity operator Qobj.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  1.  0.]</span>
<span class="go"> [ 0.  0.  1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.identity">
<tt class="descname">identity</tt><big>(</big><em>N</em><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Identity operator. Alternative name to <a class="reference internal" href="#qutip.operators.qeye" title="qutip.operators.qeye"><tt class="xref py py-func docutils literal"><span class="pre">qeye</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int or list of ints</p>
<blockquote>
<div><p>Dimension of Hilbert space. If provided as a list of ints,
then the dimension is the product over this list, but the
<tt class="docutils literal"><span class="pre">dims</span></tt> property of the new Qobj are set to this list.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Identity operator Qobj.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qutrit_ops">
<tt class="descname">qutrit_ops</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#qutrit_ops"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.qutrit_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Operators for a three level system (qutrit).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">opers: array</p>
<blockquote class="last">
<div><p><cite>array</cite> of qutrit operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmam">
<tt class="descname">sigmam</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#sigmam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmam" title="Permalink to this definition">¶</a></dt>
<dd><p>Annihilation operator for Pauli spins.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmam</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.]</span>
<span class="go"> [ 1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmap">
<tt class="descname">sigmap</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#sigmap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation operator for Pauli spins.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.]</span>
<span class="go"> [ 0.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmax">
<tt class="descname">sigmax</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#sigmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-x operator</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmax</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.]</span>
<span class="go"> [ 1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmay">
<tt class="descname">sigmay</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#sigmay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmay" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-y operator.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmay</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.-1.j]</span>
<span class="go"> [ 0.+1.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmaz">
<tt class="descname">sigmaz</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#sigmaz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmaz" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-z operator.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmaz</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.]</span>
<span class="go"> [ 0. -1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.squeeze">
<tt class="descname">squeeze</tt><big>(</big><em>N</em>, <em>z</em>, <em>offset=0</em><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode Squeezing operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of hilbert space.</p>
</div></blockquote>
<p><strong>z</strong> : float/complex</p>
<blockquote>
<div><p>Squeezing parameter.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote class="last">
<div><p>Squeezing operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">squeeze</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.98441565+0.j  0.00000000+0.j  0.17585742+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.95349007+0.j  0.00000000+0.j  0.30142443+0.j]</span>
<span class="go"> [-0.17585742+0.j  0.00000000+0.j  0.98441565+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.30142443+0.j  0.00000000+0.j  0.95349007+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.squeezing">
<tt class="descname">squeezing</tt><big>(</big><em>a1</em>, <em>a2</em>, <em>z</em><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#squeezing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.squeezing" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized squeezing operator.</p>
<div class="math">
\[S(z) = \exp\left(\frac{1}{2}\left(z^*a_1a_2
- za_1^\dagger a_2^\dagger\right)\right)\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a1</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Operator 1.</p>
</div></blockquote>
<p><strong>a2</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Operator 2.</p>
</div></blockquote>
<p><strong>z</strong> : float/complex</p>
<blockquote>
<div><p>Squeezing parameter.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote class="last">
<div><p>Squeezing operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.phase">
<tt class="descname">phase</tt><big>(</big><em>N</em>, <em>phi0=0</em><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#phase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode Pegg-Barnett phase operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of basis states in Hilbert space.</p>
</div></blockquote>
<p><strong>phi0</strong> : float</p>
<blockquote>
<div><p>Reference phase.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Phase operator with respect to reference phase.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Pegg-Barnett phase operator is Hermitian on a truncated Hilbert space.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.enr_destroy">
<tt class="descname">enr_destroy</tt><big>(</big><em>dims</em>, <em>excitations</em><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#enr_destroy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.enr_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate annilation operators for modes in a excitation-number-restricted
state space. For example, consider a system consisting of 4 modes, each
with 5 states. The total hilbert space size is 5**4 = 625. If we are
only interested in states that contain up to 2 excitations, we only need
to include states such as</p>
<blockquote>
<div>(0, 0, 0, 0)
(0, 0, 0, 1)
(0, 0, 0, 2)
(0, 0, 1, 0)
(0, 0, 1, 1)
(0, 0, 2, 0)
...</div></blockquote>
<p>This function creates annihilation operators for the 4 modes that act
within this state space:</p>
<blockquote>
<div>a1, a2, a3, a4 = enr_destroy([5, 5, 5, 5], excitations=2)</div></blockquote>
<p>From this point onwards, the annihiltion operators a1, ..., a4 can be
used to setup a Hamiltonian, collapse operators and expectation-value
operators, etc., following the usual pattern.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list</p>
<blockquote>
<div><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</div></blockquote>
<p><strong>excitations</strong> : integer</p>
<blockquote>
<div><p>The maximum number of excitations that are to be included in the
state space.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>a_ops</strong> : list of qobj</p>
<blockquote class="last">
<div><p>A list of annihilation operators for each mode in the composite
quantum system described by dims.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.enr_identity">
<tt class="descname">enr_identity</tt><big>(</big><em>dims</em>, <em>excitations</em><big>)</big><a class="reference internal" href="../modules/qutip/operators.html#enr_identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.enr_identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the identity operator for the excitation-number restricted
state space defined by the <cite>dims</cite> and <cite>exciations</cite> arguments. See the
docstring for enr_fock for a more detailed description of these arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list</p>
<blockquote>
<div><p>A list of the dimensions of each subsystem of a composite quantum
system.</p>
</div></blockquote>
<p><strong>excitations</strong> : integer</p>
<blockquote>
<div><p>The maximum number of excitations that are to be included in the
state space.</p>
</div></blockquote>
<p><strong>state</strong> : list of integers</p>
<blockquote>
<div><p>The state in the number basis representation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>op</strong> : Qobj</p>
<blockquote class="last">
<div><p>A Qobj instance that represent the identity operator in the
exication-number-restricted state space defined by <cite>dims</cite> and
<cite>exciations</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.random_objects">
<span id="random-operators-and-states"></span><span id="functions-rand"></span><h3>Random Operators and States<a class="headerlink" href="#module-qutip.random_objects" title="Permalink to this headline">¶</a></h3>
<p>This module is a collection of random state and operator generators.
The sparsity of the ouput Qobj&#8217;s is controlled by varing the
<cite>density</cite> parameter.</p>
<dl class="function">
<dt id="qutip.random_objects.rand_dm">
<tt class="descname">rand_dm</tt><big>(</big><em>N</em>, <em>density=0.75</em>, <em>pure=False</em>, <em>dims=None</em><big>)</big><a class="reference internal" href="../modules/qutip/random_objects.html#rand_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Shape of output density matrix.</p>
</div></blockquote>
<p><strong>density</strong> : float</p>
<blockquote>
<div><p>Density between [0,1] of output density matrix.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>NxN density matrix quantum operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For small density matrices., choosing a low density will result in an error
as no diagonal elements will be generated such that <span class="math">\(Tr(\rho)=1\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_herm">
<tt class="descname">rand_herm</tt><big>(</big><em>N</em>, <em>density=0.75</em>, <em>dims=None</em><big>)</big><a class="reference internal" href="../modules/qutip/random_objects.html#rand_herm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_herm" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN sparse Hermitian quantum object.</p>
<p>Uses <span class="math">\(H=X+X^{+}\)</span> where <span class="math">\(X\)</span> is
a randomly generated quantum operator with a given <cite>density</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Shape of output quantum operator.</p>
</div></blockquote>
<p><strong>density</strong> : float</p>
<blockquote>
<div><p>Density between [0,1] of output Hermitian operator.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>NxN Hermitian quantum operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_ket">
<tt class="descname">rand_ket</tt><big>(</big><em>N</em>, <em>density=1</em>, <em>dims=None</em><big>)</big><a class="reference internal" href="../modules/qutip/random_objects.html#rand_ket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random Nx1 sparse ket vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of rows for output quantum operator.</p>
</div></blockquote>
<p><strong>density</strong> : float</p>
<blockquote>
<div><p>Density between [0,1] of output ket state.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[1]].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Nx1 ket state quantum operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_unitary">
<tt class="descname">rand_unitary</tt><big>(</big><em>N</em>, <em>density=0.75</em>, <em>dims=None</em><big>)</big><a class="reference internal" href="../modules/qutip/random_objects.html#rand_unitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN sparse unitary quantum object.</p>
<p>Uses <span class="math">\(\exp(-iH)\)</span> where H is a randomly generated
Hermitian operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Shape of output quantum operator.</p>
</div></blockquote>
<p><strong>density</strong> : float</p>
<blockquote>
<div><p>Density between [0,1] of output Unitary operator.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>NxN Unitary quantum operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.three_level_atom">
<span id="three-level-atoms"></span><h3>Three-Level Atoms<a class="headerlink" href="#module-qutip.three_level_atom" title="Permalink to this headline">¶</a></h3>
<p>This module provides functions that are useful for simulating the
three level atom with QuTiP.  A three level atom (qutrit) has three states,
which are linked by dipole transitions so that 1 &lt;-&gt; 2 &lt;-&gt; 3.
Depending on there relative energies they are in the ladder, lambda or
vee configuration. The structure of the relevant operators is the same
for any of the three configurations:</p>
<div class="highlight-python"><div class="highlight"><pre>Ladder:          Lambda:                 Vee:
                            |two&gt;                       |three&gt;
  -------|three&gt;           -------                      -------
     |                       / \             |one&gt;         /
     |                      /   \           -------       /
     |                     /     \             \         /
  -------|two&gt;            /       \             \       /
     |                   /         \             \     /
     |                  /           \             \   /
     |                 /        --------           \ /
  -------|one&gt;      -------      |three&gt;         -------
                     |one&gt;                       |two&gt;
</pre></div>
</div>
<div class="section" id="references">
<h4>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h4>
<p>The naming of qutip operators follows the convention in <a class="reference internal" href="#r1" id="id2">[R1]</a> .</p>
<table class="docutils citation" frame="void" id="r1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[R1]</a></td><td>Shore, B. W., &#8220;The Theory of Coherent Atomic Excitation&#8221;,
Wiley, 1990.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="notes">
<h4>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h4>
<p>Contributed by Markus Baden, Oct. 07, 2011</p>
<dl class="function">
<dt id="qutip.three_level_atom.three_level_basis">
<tt class="descname">three_level_basis</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/qutip/three_level_atom.html#three_level_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.three_level_atom.three_level_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis states for a three level atom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>states</strong> : array</p>
<blockquote class="last">
<div><p><cite>array</cite> of three level atom basis vectors.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.three_level_atom.three_level_ops">
<tt class="descname">three_level_ops</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/qutip/three_level_atom.html#three_level_ops"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.three_level_atom.three_level_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Operators for a three level system (qutrit)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ops</strong> : array</p>
<blockquote class="last">
<div><p><cite>array</cite> of three level operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-qutip.superoperator">
<span id="superoperators-and-liouvillians"></span><h3>Superoperators and Liouvillians<a class="headerlink" href="#module-qutip.superoperator" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.superoperator.operator_to_vector">
<tt class="descname">operator_to_vector</tt><big>(</big><em>op</em><big>)</big><a class="reference internal" href="../modules/qutip/superoperator.html#operator_to_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.operator_to_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a vector representation of a quantum operator given
the matrix representation.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.vector_to_operator">
<tt class="descname">vector_to_operator</tt><big>(</big><em>op</em><big>)</big><a class="reference internal" href="../modules/qutip/superoperator.html#vector_to_operator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.vector_to_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a matrix representation given a quantum operator in
vector form.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.liouvillian">
<tt class="descname">liouvillian</tt><big>(</big><em>H</em>, <em>c_ops=[]</em>, <em>data_only=False</em>, <em>chi=None</em><big>)</big><a class="reference internal" href="../modules/qutip/superoperator.html#liouvillian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.liouvillian" title="Permalink to this definition">¶</a></dt>
<dd><p>Assembles the Liouvillian superoperator from a Hamiltonian
and a <tt class="docutils literal"><span class="pre">list</span></tt> of collapse operators. Like liouvillian, but with an
experimental implementation which avoids creating extra Qobj instances,
which can be advantageous for large systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : qobj</p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>c_ops</strong> : array_like</p>
<blockquote>
<div><p>A <tt class="docutils literal"><span class="pre">list</span></tt> or <tt class="docutils literal"><span class="pre">array</span></tt> of collapse operators.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>L</strong> : qobj</p>
<blockquote class="last">
<div><p>Liouvillian superoperator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.spost">
<tt class="descname">spost</tt><big>(</big><em>A</em><big>)</big><a class="reference internal" href="../modules/qutip/superoperator.html#spost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.spost" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from post-multiplication by operator A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Quantum operator for post multiplication.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>super</strong> : qobj</p>
<blockquote class="last">
<div><p>Superoperator formed from input qauntum object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.spre">
<tt class="descname">spre</tt><big>(</big><em>A</em><big>)</big><a class="reference internal" href="../modules/qutip/superoperator.html#spre"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.spre" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from pre-multiplication by operator A.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Quantum operator for pre-multiplication.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">super :qobj</p>
<blockquote class="last">
<div><p>Superoperator formed from input quantum object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.sprepost">
<tt class="descname">sprepost</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="reference internal" href="../modules/qutip/superoperator.html#sprepost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.sprepost" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from pre-multiplication by operator A and post-
multiplication of operator B.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : Qobj</p>
<blockquote>
<div><p>Quantum operator for pre-multiplication.</p>
</div></blockquote>
<p><strong>B</strong> : Qobj</p>
<blockquote>
<div><p>Quantum operator for post-multiplication.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>super</strong> : Qobj</p>
<blockquote class="last">
<div><p>Superoperator formed from input quantum objects.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.lindblad_dissipator">
<tt class="descname">lindblad_dissipator</tt><big>(</big><em>a</em>, <em>b=None</em>, <em>data_only=False</em><big>)</big><a class="reference internal" href="../modules/qutip/superoperator.html#lindblad_dissipator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.lindblad_dissipator" title="Permalink to this definition">¶</a></dt>
<dd><p>Lindblad dissipator (generalized) for a single pair of collapse operators
(a, b), or for a single collapse operator (a) when b is not specified:</p>
<div class="math">
\[\mathcal{D}[a,b]\rho = a \rho b^\dagger -
\frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : qobj</p>
<blockquote>
<div><p>Left part of collapse operator.</p>
</div></blockquote>
<p><strong>b</strong> : qobj (optional)</p>
<blockquote>
<div><p>Right part of collapse operator. If not specified, b defaults to a.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>D</strong> : qobj</p>
<blockquote class="last">
<div><p>Lindblad dissipator superoperator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.superop_reps">
<span id="superoperator-representations"></span><h3>Superoperator Representations<a class="headerlink" href="#module-qutip.superop_reps" title="Permalink to this headline">¶</a></h3>
<p>This module implements transformations between superoperator representations,
including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.</p>
<dl class="function">
<dt id="qutip.superop_reps.to_choi">
<tt class="descname">to_choi</tt><big>(</big><em>q_oper</em><big>)</big><a class="reference internal" href="../modules/qutip/superop_reps.html#to_choi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superop_reps.to_choi" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to the Choi representation,
such that the trace of the returned operator is equal to the dimension
of the system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q_oper</strong> : Qobj</p>
<blockquote>
<div><p>Superoperator to be converted to Choi representation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>choi</strong> : Qobj</p>
<blockquote>
<div><p>A quantum object representing the same map as <tt class="docutils literal"><span class="pre">q_oper</span></tt>, such that
<tt class="docutils literal"><span class="pre">choi.superrep</span> <span class="pre">==</span> <span class="pre">&quot;choi&quot;</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError: if the given quantum object is not a map, or cannot be converted</strong></p>
<blockquote class="last">
<div><p>to Choi representation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superop_reps.to_super">
<tt class="descname">to_super</tt><big>(</big><em>q_oper</em><big>)</big><a class="reference internal" href="../modules/qutip/superop_reps.html#to_super"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superop_reps.to_super" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to the supermatrix (Liouville)
representation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q_oper</strong> : Qobj</p>
<blockquote>
<div><p>Superoperator to be converted to supermatrix representation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>superop</strong> : Qobj</p>
<blockquote>
<div><p>A quantum object representing the same map as <tt class="docutils literal"><span class="pre">q_oper</span></tt>, such that
<tt class="docutils literal"><span class="pre">superop.superrep</span> <span class="pre">==</span> <span class="pre">&quot;super&quot;</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError: if the given quantum object is not a map, or cannot be converted</strong></p>
<blockquote class="last">
<div><p>to supermatrix representation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superop_reps.to_kraus">
<tt class="descname">to_kraus</tt><big>(</big><em>q_oper</em><big>)</big><a class="reference internal" href="../modules/qutip/superop_reps.html#to_kraus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superop_reps.to_kraus" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to a list of quantum objects,
each representing an operator in the Kraus decomposition of the given map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q_oper</strong> : Qobj</p>
<blockquote>
<div><p>Superoperator to be converted to Kraus representation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>kraus_ops</strong> : list of Qobj</p>
<blockquote>
<div><p>A list of quantum objects, each representing a Kraus operator in the
decomposition of <tt class="docutils literal"><span class="pre">q_oper</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError: if the given quantum object is not a map, or cannot be</strong></p>
<blockquote class="last">
<div><p>decomposed into Kraus operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="functions-acting-on-states-and-operators">
<h2>Functions acting on states and operators<a class="headerlink" href="#functions-acting-on-states-and-operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.tensor">
<span id="tensor"></span><h3>Tensor<a class="headerlink" href="#module-qutip.tensor" title="Permalink to this headline">¶</a></h3>
<p>Module for the creation of composite quantum objects via the tensor product.</p>
<dl class="function">
<dt id="qutip.tensor.tensor">
<tt class="descname">tensor</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="../modules/qutip/tensor.html#tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the tensor product of input operators.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>args</strong> : array_like</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> or <tt class="docutils literal"><span class="pre">array</span></tt> of quantum objects for tensor product.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>obj</strong> : qobj</p>
<blockquote class="last">
<div><p>A composite quantum object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tensor</span><span class="p">([</span><span class="n">sigmax</span><span class="p">(),</span> <span class="n">sigmax</span><span class="p">()])</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.tensor.super_tensor">
<tt class="descname">super_tensor</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="../modules/qutip/tensor.html#super_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.super_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the tensor product of input superoperators, by tensoring
together the underlying Hilbert spaces on which each vectorized operator
acts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>args</strong> : array_like</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> or <tt class="docutils literal"><span class="pre">array</span></tt> of quantum objects with <tt class="docutils literal"><span class="pre">type=&quot;super&quot;</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>obj</strong> : qobj</p>
<blockquote class="last">
<div><p>A composite quantum object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.tensor.composite">
<tt class="descname">composite</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="../modules/qutip/tensor.html#composite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.composite" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two or more operators, kets or bras, returns the Qobj
corresponding to a composite system over each argument.
For ordinary operators and vectors, this is the tensor product,
while for superoperators and vectorized operators, this is
the column-reshuffled tensor product.</p>
<p>If a mix of Qobjs supported on Hilbert and Liouville spaces
are passed in, the former are promoted. Ordinary operators
are assumed to be unitaries, and are promoted using <tt class="docutils literal"><span class="pre">to_super</span></tt>,
while kets and bras are promoted by taking their projectors and
using <tt class="docutils literal"><span class="pre">operator_to_vector(ket2dm(arg))</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.tensor.tensor_contract">
<tt class="descname">tensor_contract</tt><big>(</big><em>qobj</em>, <em>*pairs</em><big>)</big><a class="reference internal" href="../modules/qutip/tensor.html#tensor_contract"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.tensor_contract" title="Permalink to this definition">¶</a></dt>
<dd><p>Contracts a qobj along one or more index pairs.
Note that this uses dense representations and thus
should <em>not</em> be used for very large Qobjs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>pairs</strong> : tuple</p>
<blockquote>
<div><p>One or more tuples <tt class="docutils literal"><span class="pre">(i,</span> <span class="pre">j)</span></tt> indicating that the
<tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">j</span></tt> dimensions of the original qobj
should be contracted.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cqobj</strong> : Qobj</p>
<blockquote class="last">
<div><p>The original Qobj with all named index pairs contracted
away.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.expect">
<span id="expectation-values"></span><h3>Expectation Values<a class="headerlink" href="#module-qutip.expect" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.expect.expect">
<tt class="descname">expect</tt><big>(</big><em>oper</em>, <em>state</em><big>)</big><a class="reference internal" href="../modules/qutip/expect.html#expect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.expect.expect" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation value for operator(s) and state(s).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj/array-like</p>
<blockquote>
<div><p>A single or a <cite>list</cite> or operators for expectation value.</p>
</div></blockquote>
<p><strong>state</strong> : qobj/array-like</p>
<blockquote>
<div><p>A single or a <cite>list</cite> of quantum states or density matrices.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>expt</strong> : float/complex/array-like</p>
<blockquote class="last">
<div><p>Expectation value.  <tt class="docutils literal"><span class="pre">real</span></tt> if <cite>oper</cite> is Hermitian, <tt class="docutils literal"><span class="pre">complex</span></tt>
otherwise. A (nested) array of expectaction values of state or operator
are arrays.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">expect</span><span class="p">(</span><span class="n">num</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">basis</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.expect.variance">
<tt class="descname">variance</tt><big>(</big><em>oper</em>, <em>state</em><big>)</big><a class="reference internal" href="../modules/qutip/expect.html#variance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.expect.variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Variance of an operator for the given state vector or density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote>
<div><p>Operator for expectation value.</p>
</div></blockquote>
<p><strong>state</strong> : qobj/list</p>
<blockquote>
<div><p>A single or <cite>list</cite> of quantum states or density matrices..</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>var</strong> : float</p>
<blockquote class="last">
<div><p>Variance of operator &#8216;oper&#8217; for given state.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.partial_transpose">
<span id="partial-transpose"></span><h3>Partial Transpose<a class="headerlink" href="#module-qutip.partial_transpose" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.partial_transpose.partial_transpose">
<tt class="descname">partial_transpose</tt><big>(</big><em>rho</em>, <em>mask</em>, <em>method='dense'</em><big>)</big><a class="reference internal" href="../modules/qutip/partial_transpose.html#partial_transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.partial_transpose.partial_transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the partial transpose of a Qobj instance <cite>rho</cite>,
where <cite>mask</cite> is an array/list with length that equals
the number of components of <cite>rho</cite> (that is, the length of
<cite>rho.dims[0]</cite>), and the values in <cite>mask</cite> indicates whether
or not the corresponding subsystem is to be transposed.
The elements in <cite>mask</cite> can be boolean or integers <cite>0</cite> or <cite>1</cite>,
where <cite>True</cite>/<cite>1</cite> indicates that the corresponding subsystem
should be tranposed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>A density matrix.</p>
</div></blockquote>
<p><strong>mask</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>A mask that selects which subsystems should be transposed.</p>
</div></blockquote>
<p><strong>method</strong> : str</p>
<blockquote>
<div><p>choice of method, <cite>dense</cite> or <cite>sparse</cite>. The default method
is <cite>dense</cite>. The <cite>sparse</cite> implementation can be faster for
large and sparse systems (hundreds of quantum states).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">rho_pr: <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote class="last">
<div><p>A density matrix with the selected subsystems transposed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.entropy">
<span id="entropy-functions"></span><span id="functions-entropy"></span><h3>Entropy Functions<a class="headerlink" href="#module-qutip.entropy" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.entropy.concurrence">
<tt class="descname">concurrence</tt><big>(</big><em>rho</em><big>)</big><a class="reference internal" href="../modules/qutip/entropy.html#concurrence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.concurrence" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the concurrence entanglement measure for a two-qubit state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote>
<div><p>Ket, bra, or density matrix for a two-qubit state.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>concur</strong> : float</p>
<blockquote class="last">
<div><p>Concurrence</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[R2]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Concurrence_(quantum_computing">http://en.wikipedia.org/wiki/Concurrence_(quantum_computing</a>)</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_conditional">
<tt class="descname">entropy_conditional</tt><big>(</big><em>rho</em>, <em>selB</em>, <em>base=2.718281828459045</em>, <em>sparse=False</em><big>)</big><a class="reference internal" href="../modules/qutip/entropy.html#entropy_conditional"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_conditional" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the conditional entropy <span class="math">\(S(A|B)=S(A,B)-S(B)\)</span>
of a slected density matrix component.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : qobj</p>
<blockquote>
<div><p>Density matrix of composite object</p>
</div></blockquote>
<p><strong>selB</strong> : int/list</p>
<blockquote>
<div><p>Selected components for density matrix B</p>
</div></blockquote>
<p><strong>base</strong> : {e,2}</p>
<blockquote>
<div><p>Base of logarithm.</p>
</div></blockquote>
<p><strong>sparse</strong> : {False,True}</p>
<blockquote>
<div><p>Use sparse eigensolver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ent_cond</strong> : float</p>
<blockquote class="last">
<div><p>Value of conditional entropy</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_linear">
<tt class="descname">entropy_linear</tt><big>(</big><em>rho</em><big>)</big><a class="reference internal" href="../modules/qutip/entropy.html#entropy_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear entropy of a density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : qobj</p>
<blockquote>
<div><p>sensity matrix or ket/bra vector.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>entropy</strong> : float</p>
<blockquote class="last">
<div><p>Linear entropy of rho.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy_linear</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_mutual">
<tt class="descname">entropy_mutual</tt><big>(</big><em>rho</em>, <em>selA</em>, <em>selB</em>, <em>base=2.718281828459045</em>, <em>sparse=False</em><big>)</big><a class="reference internal" href="../modules/qutip/entropy.html#entropy_mutual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_mutual" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the mutual information S(A:B) between selection
components of a system density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : qobj</p>
<blockquote>
<div><p>Density matrix for composite quantum systems</p>
</div></blockquote>
<p><strong>selA</strong> : int/list</p>
<blockquote>
<div><p><cite>int</cite> or <cite>list</cite> of first selected density matrix components.</p>
</div></blockquote>
<p><strong>selB</strong> : int/list</p>
<blockquote>
<div><p><cite>int</cite> or <cite>list</cite> of second selected density matrix components.</p>
</div></blockquote>
<p><strong>base</strong> : {e,2}</p>
<blockquote>
<div><p>Base of logarithm.</p>
</div></blockquote>
<p><strong>sparse</strong> : {False,True}</p>
<blockquote>
<div><p>Use sparse eigensolver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ent_mut</strong> : float</p>
<blockquote class="last">
<div><p>Mutual information between selected components.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_vn">
<tt class="descname">entropy_vn</tt><big>(</big><em>rho</em>, <em>base=2.718281828459045</em>, <em>sparse=False</em><big>)</big><a class="reference internal" href="../modules/qutip/entropy.html#entropy_vn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_vn" title="Permalink to this definition">¶</a></dt>
<dd><p>Von-Neumann entropy of density matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : qobj</p>
<blockquote>
<div><p>Density matrix.</p>
</div></blockquote>
<p><strong>base</strong> : {e,2}</p>
<blockquote>
<div><p>Base of logarithm.</p>
</div></blockquote>
<p><strong>sparse</strong> : {False,True}</p>
<blockquote>
<div><p>Use sparse eigensolver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>entropy</strong> : float</p>
<blockquote class="last">
<div><p>Von-Neumann entropy of <cite>rho</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy_vn</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-qutip.metrics">
<span id="density-matrix-metrics"></span><h3>Density Matrix Metrics<a class="headerlink" href="#module-qutip.metrics" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection of functions for calculating metrics
(distance measures) between states and operators.</p>
<dl class="function">
<dt id="qutip.metrics.fidelity">
<tt class="descname">fidelity</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="reference internal" href="../modules/qutip/metrics.html#fidelity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the fidelity (pseudo-metric) between two density matrices.
See: Nielsen &amp; Chuang, &#8220;Quantum Computation and Quantum Information&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector.</p>
</div></blockquote>
<p><strong>B</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector with same dimensions as A.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fid</strong> : float</p>
<blockquote class="last">
<div><p>Fidelity pseudo-metric between A and B.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">0.24104350624628332</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.tracedist">
<tt class="descname">tracedist</tt><big>(</big><em>A</em>, <em>B</em>, <em>sparse=False</em>, <em>tol=0</em><big>)</big><a class="reference internal" href="../modules/qutip/metrics.html#tracedist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.tracedist" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the trace distance between two density matrices..
See: Nielsen &amp; Chuang, &#8220;Quantum Computation and Quantum Information&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector.</p>
</div></blockquote>
<p><strong>B</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector with same dimensions as A.</p>
</div></blockquote>
<p><strong>tol</strong> : float</p>
<blockquote>
<div><p>Tolerance used by sparse eigensolver, if used. (0=Machine precision)</p>
</div></blockquote>
<p><strong>sparse</strong> : {False, True}</p>
<blockquote>
<div><p>Use sparse eigensolver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tracedist</strong> : float</p>
<blockquote class="last">
<div><p>Trace distance between A and B.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">=</span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tracedist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">0.9705143161472971</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.bures_dist">
<tt class="descname">bures_dist</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="reference internal" href="../modules/qutip/metrics.html#bures_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.bures_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Bures distance between two density matrices A &amp; B.</p>
<p>The Bures distance ranges from 0, for states with unit fidelity,
to sqrt(2).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector.</p>
</div></blockquote>
<p><strong>B</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector with same dimensions as A.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dist</strong> : float</p>
<blockquote class="last">
<div><p>Bures distance between density matrices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.bures_angle">
<tt class="descname">bures_angle</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="reference internal" href="../modules/qutip/metrics.html#bures_angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.bures_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Bures Angle between two density matrices A &amp; B.</p>
<p>The Bures angle ranges from 0, for states with unit fidelity, to pi/2.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector.</p>
</div></blockquote>
<p><strong>B</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector with same dimensions as A.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>angle</strong> : float</p>
<blockquote class="last">
<div><p>Bures angle between density matrices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.hilbert_dist">
<tt class="descname">hilbert_dist</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="reference internal" href="../modules/qutip/metrics.html#hilbert_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.hilbert_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Hilbert-Schmidt distance between two density matrices A &amp; B.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector.</p>
</div></blockquote>
<p><strong>B</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector with same dimensions as A.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dist</strong> : float</p>
<blockquote class="last">
<div><p>Hilbert-Schmidt distance between density matrices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.average_gate_fidelity">
<tt class="descname">average_gate_fidelity</tt><big>(</big><em>oper</em><big>)</big><a class="reference internal" href="../modules/qutip/metrics.html#average_gate_fidelity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.average_gate_fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a Qobj representing the supermatrix form of a map, returns the
average gate fidelity (pseudo-metric) of that map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : Qobj</p>
<blockquote>
<div><p>Quantum object representing a superoperator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fid</strong> : float</p>
<blockquote class="last">
<div><p>Fidelity pseudo-metric between A and the identity superoperator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.process_fidelity">
<tt class="descname">process_fidelity</tt><big>(</big><em>U1</em>, <em>U2</em>, <em>normalize=True</em><big>)</big><a class="reference internal" href="../modules/qutip/metrics.html#process_fidelity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.process_fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the process fidelity given two process operators.</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.continuous_variables">
<span id="continous-variables"></span><h3>Continous Variables<a class="headerlink" href="#module-qutip.continuous_variables" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection functions for calculating continuous variable
quantities from fock-basis representation of the state of multi-mode fields.</p>
<dl class="function">
<dt id="qutip.continuous_variables.correlation_matrix">
<tt class="descname">correlation_matrix</tt><big>(</big><em>basis</em>, <em>rho=None</em><big>)</big><a class="reference internal" href="../modules/qutip/continuous_variables.html#correlation_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a basis set of operators <span class="math">\(\{a\}_n\)</span>, calculate the correlation
matrix:</p>
<div class="math">
\[C_{mn} = \langle a_m a_n \rangle\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>basis</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>List of operators that defines the basis for the correlation matrix.</p>
</div></blockquote>
<p><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Density matrix for which to calculate the correlation matrix. If
<cite>rho</cite> is <cite>None</cite>, then a matrix of correlation matrix operators is
returned instead of expectation values of those operators.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">corr_mat: <em>array</em></p>
<blockquote class="last">
<div><p>A 2-dimensional <em>array</em> of correlation values or operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.covariance_matrix">
<tt class="descname">covariance_matrix</tt><big>(</big><em>basis</em>, <em>rho</em>, <em>symmetrized=True</em><big>)</big><a class="reference internal" href="../modules/qutip/continuous_variables.html#covariance_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a basis set of operators <span class="math">\(\{a\}_n\)</span>, calculate the covariance
matrix:</p>
<div class="math">
\[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -
\langle a_m \rangle \langle a_n\rangle\]</div>
<p>or, if of the optional argument <cite>symmetrized=False</cite>,</p>
<div class="math">
\[V_{mn} = \langle a_m a_n\rangle -
\langle a_m \rangle \langle a_n\rangle\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>basis</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>List of operators that defines the basis for the covariance matrix.</p>
</div></blockquote>
<p><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Density matrix for which to calculate the covariance matrix.</p>
</div></blockquote>
<p><strong>symmetrized</strong> : <em>bool</em></p>
<blockquote>
<div><p>Flag indicating whether the symmetrized (default) or non-symmetrized
correlation matrix is to be calculated.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">corr_mat: <em>array</em></p>
<blockquote class="last">
<div><p>A 2-dimensional <em>array</em> of covariance values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.correlation_matrix_field">
<tt class="descname">correlation_matrix_field</tt><big>(</big><em>a1</em>, <em>a2</em>, <em>rho=None</em><big>)</big><a class="reference internal" href="../modules/qutip/continuous_variables.html#correlation_matrix_field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the correlation matrix for given field operators <span class="math">\(a_1\)</span> and
<span class="math">\(a_2\)</span>. If a density matrix is given the expectation values are
calculated, otherwise a matrix with operators is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a1</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Field operator for mode 1.</p>
</div></blockquote>
<p><strong>a2</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Field operator for mode 2.</p>
</div></blockquote>
<p><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Density matrix for which to calculate the covariance matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">cov_mat: <em>array</em> of complex numbers or <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote class="last">
<div><p>A 2-dimensional <em>array</em> of covariance values, or, if rho=0, a matrix
of operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.correlation_matrix_quadrature">
<tt class="descname">correlation_matrix_quadrature</tt><big>(</big><em>a1</em>, <em>a2</em>, <em>rho=None</em><big>)</big><a class="reference internal" href="../modules/qutip/continuous_variables.html#correlation_matrix_quadrature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix_quadrature" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the quadrature correlation matrix with given field operators
<span class="math">\(a_1\)</span> and <span class="math">\(a_2\)</span>. If a density matrix is given the expectation
values are calculated, otherwise a matrix with operators is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a1</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Field operator for mode 1.</p>
</div></blockquote>
<p><strong>a2</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Field operator for mode 2.</p>
</div></blockquote>
<p><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Density matrix for which to calculate the covariance matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">corr_mat: <em>array</em> of complex numbers or <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote class="last">
<div><p>A 2-dimensional <em>array</em> of covariance values for the field quadratures,
or, if rho=0, a matrix of operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.wigner_covariance_matrix">
<tt class="descname">wigner_covariance_matrix</tt><big>(</big><em>a1=None</em>, <em>a2=None</em>, <em>R=None</em>, <em>rho=None</em><big>)</big><a class="reference internal" href="../modules/qutip/continuous_variables.html#wigner_covariance_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.wigner_covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Wigner covariance matrix
<span class="math">\(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\)</span>, given
the quadrature correlation matrix
<span class="math">\(R_{ij} = \langle R_{i} R_{j}\rangle -
\langle R_{i}\rangle \langle R_{j}\rangle\)</span>, where
<span class="math">\(R = (q_1, p_1, q_2, p_2)^T\)</span> is the vector with quadrature operators
for the two modes.</p>
<p>Alternatively, if <cite>R = None</cite>, and if annihilation operators <cite>a1</cite> and <cite>a2</cite>
for the two modes are supplied instead, the quadrature correlation matrix
is constructed from the annihilation operators before then the covariance
matrix is calculated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a1</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Field operator for mode 1.</p>
</div></blockquote>
<p><strong>a2</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Field operator for mode 2.</p>
</div></blockquote>
<p><strong>R</strong> : <em>array</em></p>
<blockquote>
<div><p>The quadrature correlation matrix.</p>
</div></blockquote>
<p><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Density matrix for which to calculate the covariance matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">cov_mat: <em>array</em></p>
<blockquote class="last">
<div><p>A 2-dimensional <em>array</em> of covariance values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.logarithmic_negativity">
<tt class="descname">logarithmic_negativity</tt><big>(</big><em>V</em><big>)</big><a class="reference internal" href="../modules/qutip/continuous_variables.html#logarithmic_negativity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.logarithmic_negativity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the logarithmic negativity given the symmetrized covariance
matrix, see <tt class="xref py py-func docutils literal"><span class="pre">qutip.continous_variables.covariance_matrix</span></tt>. Note that
the two-mode field state that is described by <cite>V</cite> must be Gaussian for this
function to applicable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>V</strong> : <em>2d array</em></p>
<blockquote>
<div><p>The covariance matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">N: <em>float</em>, the logarithmic negativity for the two-mode Gaussian state</p>
<p class="last">that is described by the the Wigner covariance matrix V.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="dynamics-and-time-evolution">
<h2>Dynamics and Time-Evolution<a class="headerlink" href="#dynamics-and-time-evolution" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.sesolve">
<span id="schrodinger-equation"></span><h3>Schrödinger Equation<a class="headerlink" href="#module-qutip.sesolve" title="Permalink to this headline">¶</a></h3>
<p>This module provides solvers for the unitary Schrodinger equation.</p>
<dl class="function">
<dt id="qutip.sesolve.sesolve">
<tt class="descname">sesolve</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>e_ops</em>, <em>args={}</em>, <em>options=None</em>, <em>progress_bar=&lt;qutip.ui.progressbar.BaseProgressBar object at 0x105876c90&gt;</em><big>)</big><a class="reference internal" href="../modules/qutip/sesolve.html#sesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.sesolve.sesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Schrodinger equation evolution of a state vector for a given Hamiltonian.</p>
<p>Evolve the state vector or density matrix (<cite>rho0</cite>) using a given
Hamiltonian (<cite>H</cite>), by integrating the set of ordinary differential
equations that define the system.</p>
<p>The output is either the state vector at arbitrary points in time
(<cite>tlist</cite>), or the expectation values of the supplied operators
(<cite>e_ops</cite>). If e_ops is a callback function, it is invoked for each
time in <cite>tlist</cite> with time and the state as arguments, and the function
does not use any return values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian, or a callback function for time-dependent
Hamiltonians.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> / callback function single</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>args</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
</div></blockquote>
<p><strong>options</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.Qdeoptions</span></tt></p>
<blockquote>
<div><p>with options for the ODE solver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">output: <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></tt></p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></tt>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>, or
an <em>array</em> or state vectors or density matrices corresponding to the
times in <cite>tlist</cite> [if <cite>e_ops</cite> is an empty list], or
nothing if a callback function was given inplace of operators for
which to calculate the expectation values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.mesolve">
<span id="master-equation"></span><h3>Master Equation<a class="headerlink" href="#module-qutip.mesolve" title="Permalink to this headline">¶</a></h3>
<p>This module provides solvers for the Lindblad master equation and von Neumann
equation.</p>
<dl class="function">
<dt id="qutip.mesolve.mesolve">
<tt class="descname">mesolve</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>c_ops</em>, <em>e_ops</em>, <em>args={}</em>, <em>options=None</em>, <em>progress_bar=None</em><big>)</big><a class="reference internal" href="../modules/qutip/mesolve.html#mesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.mesolve.mesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Master equation evolution of a density matrix for a given Hamiltonian and
set of collapse operators, or a Liouvillian.</p>
<p>Evolve the state vector or density matrix (<cite>rho0</cite>) using a given
Hamiltonian (<cite>H</cite>) and an [optional] set of collapse operators
(<cite>c_ops</cite>), by integrating the set of ordinary differential equations
that define the system. In the absence of collapse operators the system is
evolved according to the unitary evolution of the Hamiltonian.</p>
<p>The output is either the state vector at arbitrary points in time
(<cite>tlist</cite>), or the expectation values of the supplied operators
(<cite>e_ops</cite>). If e_ops is a callback function, it is invoked for each
time in <cite>tlist</cite> with time and the state as arguments, and the function
does not use any return values.</p>
<p>If either <cite>H</cite> or the Qobj elements in <cite>c_ops</cite> are superoperators, they
will be treated as direct contributions to the total system Liouvillian.
This allows to solve master equations that are not on standard Lindblad
form by passing a custom Liouvillian in place of either the <cite>H</cite> or <cite>c_ops</cite>
elements.</p>
<p><strong>Time-dependent operators</strong></p>
<p>For time-dependent problems, <cite>H</cite> and <cite>c_ops</cite> can be callback
functions that takes two arguments, time and <cite>args</cite>, and returns the
Hamiltonian or Liouvillian for the system at that point in time
(<em>callback format</em>).</p>
<p>Alternatively, <cite>H</cite> and <cite>c_ops</cite> can be a specified in a nested-list format
where each element in the list is a list of length 2, containing an
operator (<tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt>) at the first element and where the
second element is either a string (<em>list string format</em>), a callback
function (<em>list callback format</em>) that evaluates to the time-dependent
coefficient for the corresponding operator, or a NumPy array (<em>list
array format</em>) which specifies the value of the coefficient to the
corresponding operator for each value of t in tlist.</p>
<p><em>Examples</em></p>
<blockquote>
<div><p>H = [[H0, &#8216;sin(w*t)&#8217;], [H1, &#8216;sin(2*w*t)&#8217;]]</p>
<p>H = [[H0, f0_t], [H1, f1_t]]</p>
<p>where f0_t and f1_t are python functions with signature f_t(t, args).</p>
<p>H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]</p>
</div></blockquote>
<p>In the <em>list string format</em> and <em>list callback format</em>, the string
expression and the callback function must evaluate to a real or complex
number (coefficient for the corresponding operator).</p>
<p>In all cases of time-dependent operators, <cite>args</cite> is a dictionary of
parameters that is used when evaluating operators. It is passed to the
callback functions as second argument.</p>
<p><strong>Additional options</strong></p>
<p>Additional options to mesolve can be set via the <cite>options</cite> argument, which
should be an instance of <a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Options</span></tt></a>. Many ODE
integration options can be set this way, and the <cite>store_states</cite> and
<cite>store_final_state</cite> options can be used to store states even though
expectation values are requested via the <cite>e_ops</cite> argument.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If an element in the list-specification of the Hamiltonian or
the list of collapse operators are in superoperator form it will be
added to the total Liouvillian of the problem with out further
transformation. This allows for using mesolve for solving master
equations that are not on standard Lindblad form.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On using callback function: mesolve transforms all <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt>
objects to sparse matrices before handing the problem to the integrator
function. In order for your callback function to work correctly, pass
all <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> objects that are used in constructing the
Hamiltonian via args. mesolve will check for <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> in
<cite>args</cite> and handle the conversion to sparse matrices. All other
<tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> objects that are not passed via <cite>args</cite> will be
passed on to the integrator in scipy which will raise an NotImplemented
exception.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>System Hamiltonian, or a callback function for time-dependent
Hamiltonians, or alternatively a system Liouvillian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>single collapse operator, or list of collapse operators, or a list
of Liouvillian superoperators.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a> / callback function single</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>args</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
</div></blockquote>
<p><strong>options</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.Options</span></tt></p>
<blockquote>
<div><p>with options for the solver.</p>
</div></blockquote>
<p><strong>progress_bar: BaseProgressBar</strong></p>
<blockquote>
<div><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">result: <tt class="xref py py-class docutils literal"><span class="pre">qutip.Result</span></tt></p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.Result</span></tt>, which contains
either an <em>array</em> <cite>result.expect</cite> of expectation values for the times
specified by <cite>tlist</cite>, or an <em>array</em> <cite>result.states</cite> of state vectors or
density matrices corresponding to the times in <cite>tlist</cite> [if <cite>e_ops</cite> is
an empty list], or nothing if a callback function was given in place of
operators for which to calculate the expectation values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.mcsolve">
<span id="monte-carlo-evolution"></span><h3>Monte Carlo Evolution<a class="headerlink" href="#module-qutip.mcsolve" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.mcsolve.mcsolve">
<tt class="descname">mcsolve</tt><big>(</big><em>H</em>, <em>psi0</em>, <em>tlist</em>, <em>c_ops</em>, <em>e_ops</em>, <em>ntraj=None</em>, <em>args={}</em>, <em>options=None</em>, <em>progress_bar=True</em>, <em>map_func=None</em>, <em>map_kwargs=None</em><big>)</big><a class="reference internal" href="../modules/qutip/mcsolve.html#mcsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.mcsolve.mcsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Monte Carlo evolution of a state vector <span class="math">\(|\psi \rangle\)</span> for a
given Hamiltonian and sets of collapse operators, and possibly, operators
for calculating expectation values. Options for the underlying ODE solver
are given by the Options class.</p>
<p>mcsolve supports time-dependent Hamiltonians and collapse operators using
either Python functions of strings to represent time-dependent
coefficients. Note that, the system Hamiltonian MUST have at least one
constant term.</p>
<p>As an example of a time-dependent problem, consider a Hamiltonian with two
terms <tt class="docutils literal"><span class="pre">H0</span></tt> and <tt class="docutils literal"><span class="pre">H1</span></tt>, where <tt class="docutils literal"><span class="pre">H1</span></tt> is time-dependent with coefficient
<tt class="docutils literal"><span class="pre">sin(w*t)</span></tt>, and collapse operators <tt class="docutils literal"><span class="pre">C0</span></tt> and <tt class="docutils literal"><span class="pre">C1</span></tt>, where <tt class="docutils literal"><span class="pre">C1</span></tt> is
time-dependent with coeffcient <tt class="docutils literal"><span class="pre">exp(-a*t)</span></tt>.  Here, w and a are constant
arguments with values <tt class="docutils literal"><span class="pre">W</span></tt> and <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
<p>Using the Python function time-dependent format requires two Python
functions, one for each collapse coefficient. Therefore, this problem could
be expressed as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s">&#39;w&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">C1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">args</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="n">H1_coeff</span><span class="p">]]</span>

<span class="n">c_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">C0</span><span class="p">,</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="n">C1_coeff</span><span class="p">]]</span>

<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">:</span> <span class="n">W</span><span class="p">}</span>
</pre></div>
</div>
<p>or in String (Cython) format we could write:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="s">&#39;sin(w*t)&#39;</span><span class="p">]]</span>

<span class="n">c_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">C0</span><span class="p">,</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="s">&#39;exp(-a*t)&#39;</span><span class="p">]]</span>

<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">:</span> <span class="n">W</span><span class="p">}</span>
</pre></div>
</div>
<p>Constant terms are preferably placed first in the Hamiltonian and collapse
operator lists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>psi0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Initial state vector</p>
</div></blockquote>
<p><strong>tlist</strong> : array_like</p>
<blockquote>
<div><p>Times at which results are recorded.</p>
</div></blockquote>
<p><strong>ntraj</strong> : int</p>
<blockquote>
<div><p>Number of trajectories to run.</p>
</div></blockquote>
<p><strong>c_ops</strong> : array_like</p>
<blockquote>
<div><p>single collapse operator or <tt class="docutils literal"><span class="pre">list</span></tt> or <tt class="docutils literal"><span class="pre">array</span></tt> of collapse
operators.</p>
</div></blockquote>
<p><strong>e_ops</strong> : array_like</p>
<blockquote>
<div><p>single operator or <tt class="docutils literal"><span class="pre">list</span></tt> or <tt class="docutils literal"><span class="pre">array</span></tt> of operators for calculating
expectation values.</p>
</div></blockquote>
<p><strong>args</strong> : dict</p>
<blockquote>
<div><p>Arguments for time-dependent Hamiltonian and collapse operator terms.</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>Instance of ODE solver options.</p>
</div></blockquote>
<p><strong>progress_bar: BaseProgressBar</strong></p>
<blockquote>
<div><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation. Set to None to disable the
progress bar.</p>
</div></blockquote>
<p><strong>map_func: function</strong></p>
<blockquote>
<div><p>A map function for managing the calls to the single-trajactory solver.</p>
</div></blockquote>
<p><strong>map_kwargs: dictionary</strong></p>
<blockquote>
<div><p>Optional keyword arguments to the map_func function.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>results</strong> : <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></tt></a></p>
<blockquote>
<div><p>Object storing all results from the simulation.</p>
</div></blockquote>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is possible to reuse the random number seeds from a previous run
of the mcsolver by passing the output Result object seeds via the
Options class, i.e. Options(seeds=prev_result.seeds).</p>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-qutip.fortran.mcsolve_f90"></span><dl class="function">
<dt id="qutip.fortran.mcsolve_f90.mcsolve_f90">
<tt class="descname">mcsolve_f90</tt><big>(</big><em>H</em>, <em>psi0</em>, <em>tlist</em>, <em>c_ops</em>, <em>e_ops</em>, <em>ntraj=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x1048d6b48&gt;</em>, <em>sparse_dms=True</em>, <em>serial=False</em>, <em>ptrace_sel=[]</em>, <em>calc_entropy=False</em><big>)</big><a class="reference internal" href="../modules/qutip/fortran/mcsolve_f90.html#mcsolve_f90"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fortran.mcsolve_f90.mcsolve_f90" title="Permalink to this definition">¶</a></dt>
<dd><p>Monte-Carlo wave function solver with fortran 90 backend.
Usage is identical to qutip.mcsolve, for problems without explicit
time-dependence, and with some optional input:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : qobj</p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>psi0</strong> : qobj</p>
<blockquote>
<div><p>Initial state vector</p>
</div></blockquote>
<p><strong>tlist</strong> : array_like</p>
<blockquote>
<div><p>Times at which results are recorded.</p>
</div></blockquote>
<p><strong>ntraj</strong> : int</p>
<blockquote>
<div><p>Number of trajectories to run.</p>
</div></blockquote>
<p><strong>c_ops</strong> : array_like</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> or <tt class="docutils literal"><span class="pre">array</span></tt> of collapse operators.</p>
</div></blockquote>
<p><strong>e_ops</strong> : array_like</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> or <tt class="docutils literal"><span class="pre">array</span></tt> of operators for calculating expectation values.</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>Instance of solver options.</p>
</div></blockquote>
<p><strong>sparse_dms</strong> : boolean</p>
<blockquote>
<div><p>If averaged density matrices are returned, they will be stored as
sparse (Compressed Row Format) matrices during computation if
sparse_dms = True (default), and dense matrices otherwise. Dense
matrices might be preferable for smaller systems.</p>
</div></blockquote>
<p><strong>serial</strong> : boolean</p>
<blockquote>
<div><p>If True (default is False) the solver will not make use of the
multiprocessing module, and simply run in serial.</p>
</div></blockquote>
<p><strong>ptrace_sel: list</strong></p>
<blockquote>
<div><p>This optional argument specifies a list of components to keep when
returning a partially traced density matrix. This can be convenient for
large systems where memory becomes a problem, but you are only
interested in parts of the density matrix.</p>
</div></blockquote>
<p><strong>calc_entropy</strong> : boolean</p>
<blockquote>
<div><p>If ptrace_sel is specified, calc_entropy=True will have the solver
return the averaged entropy over trajectories in results.entropy. This
can be interpreted as a measure of entanglement. See Phys. Rev. Lett.
93, 120408 (2004), Phys. Rev. A 86, 022310 (2012).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>results</strong> : Result</p>
<blockquote class="last">
<div><p>Object storing all results from simulation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.essolve">
<span id="exponential-series"></span><h3>Exponential Series<a class="headerlink" href="#module-qutip.essolve" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.essolve.essolve">
<tt class="descname">essolve</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>c_op_list</em>, <em>e_ops</em><big>)</big><a class="reference internal" href="../modules/qutip/essolve.html#essolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.essolve.essolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolution of a state vector or density matrix (<cite>rho0</cite>) for a given
Hamiltonian (<cite>H</cite>) and set of collapse operators (<cite>c_op_list</cite>), by
expressing the ODE as an exponential series. The output is either
the state vector at arbitrary points in time (<cite>tlist</cite>), or the
expectation values of the supplied operators (<cite>e_ops</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : qobj/function_type</p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>Initial state density matrix.</p>
</div></blockquote>
<p><strong>tlist</strong> : list/array</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>c_op_list</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> collapse operators.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> operators for which to evaluate
expectation values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>expt_array</strong> : array</p>
<blockquote>
<div><p>Expectation values of wavefunctions/density matrices for the
times specified in <tt class="docutils literal"><span class="pre">tlist</span></tt>.</p>
</div></blockquote>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This solver does not support time-dependent Hamiltonians.</p>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.essolve.ode2es">
<tt class="descname">ode2es</tt><big>(</big><em>L</em>, <em>rho0</em><big>)</big><a class="reference internal" href="../modules/qutip/essolve.html#ode2es"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.essolve.ode2es" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an exponential series that describes the time evolution for the
initial density matrix (or state vector) <cite>rho0</cite>, given the Liouvillian
(or Hamiltonian) <cite>L</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>L</strong> : qobj</p>
<blockquote>
<div><p>Liouvillian of the system.</p>
</div></blockquote>
<p><strong>rho0</strong> : qobj</p>
<blockquote>
<div><p>Initial state vector or density matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eseries</strong> : <a class="reference internal" href="classes.html#qutip.eseries" title="qutip.eseries"><tt class="xref py py-class docutils literal"><span class="pre">qutip.eseries</span></tt></a></p>
<blockquote class="last">
<div><p><tt class="docutils literal"><span class="pre">eseries</span></tt> represention of the system dynamics.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.bloch_redfield">
<span id="bloch-redfield-master-equation"></span><h3>Bloch-Redfield Master Equation<a class="headerlink" href="#module-qutip.bloch_redfield" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.bloch_redfield.brmesolve">
<tt class="descname">brmesolve</tt><big>(</big><em>H</em>, <em>psi0</em>, <em>tlist</em>, <em>a_ops</em>, <em>e_ops=[]</em>, <em>spectra_cb=[]</em>, <em>c_ops=None</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options instance at 0x105963320&gt;</em><big>)</big><a class="reference internal" href="../modules/qutip/bloch_redfield.html#brmesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch_redfield.brmesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the dynamics for a system using the Bloch-Redfield master equation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This solver does not currently support time-dependent Hamiltonians.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0 / psi0: :class:`qutip.Qobj`</strong></p>
<blockquote>
<div><p>Initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>a_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>List of system operators that couple to bath degrees of freedom.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> / callback function</p>
<blockquote>
<div><p>List of operators for which to evaluate expectation values.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>List of system collapse operators.</p>
</div></blockquote>
<p><strong>args</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>Placeholder for future implementation, kept for API consistency.</p>
</div></blockquote>
<p><strong>options</strong> : <a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Options</span></tt></a></p>
<blockquote>
<div><p>Options for the solver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">result: <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></tt></a></p>
<blockquote class="last">
<div><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></tt></a>, which contains
either an array of expectation values, for operators given in e_ops,
or a list of states for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.bloch_redfield.bloch_redfield_tensor">
<tt class="descname">bloch_redfield_tensor</tt><big>(</big><em>H</em>, <em>a_ops</em>, <em>spectra_cb</em>, <em>c_ops=None</em>, <em>use_secular=True</em><big>)</big><a class="reference internal" href="../modules/qutip/bloch_redfield.html#bloch_redfield_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch_redfield.bloch_redfield_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Bloch-Redfield tensor for a system given a set of operators
and corresponding spectral functions that describes the system&#8217;s coupling
to its environment.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This tensor generation requires a time-independent Hamiltonian.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>a_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>List of system operators that couple to the environment.</p>
</div></blockquote>
<p><strong>spectra_cb</strong> : list of callback functions</p>
<blockquote>
<div><p>List of callback functions that evaluate the noise power spectrum
at a given frequency.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>List of system collapse operators.</p>
</div></blockquote>
<p><strong>use_secular</strong> : bool</p>
<blockquote>
<div><p>Flag (True of False) that indicates if the secular approximation should
be used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">R, kets: <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a>, list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote class="last">
<div><p>R is the Bloch-Redfield tensor and kets is a list eigenstates of the
Hamiltonian.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.bloch_redfield.bloch_redfield_solve">
<tt class="descname">bloch_redfield_solve</tt><big>(</big><em>R</em>, <em>ekets</em>, <em>rho0</em>, <em>tlist</em>, <em>e_ops=[]</em>, <em>options=None</em><big>)</big><a class="reference internal" href="../modules/qutip/bloch_redfield.html#bloch_redfield_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch_redfield.bloch_redfield_solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolve the ODEs defined by Bloch-Redfield master equation. The
Bloch-Redfield tensor can be calculated by the function
<a class="reference internal" href="#qutip.bloch_redfield.bloch_redfield_tensor" title="qutip.bloch_redfield.bloch_redfield_tensor"><tt class="xref py py-func docutils literal"><span class="pre">bloch_redfield_tensor</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>R</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>Bloch-Redfield tensor.</p>
</div></blockquote>
<p><strong>ekets</strong> : array of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>Array of kets that make up a basis tranformation for the eigenbasis.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>Initial density matrix.</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> / callback function</p>
<blockquote>
<div><p>List of operators for which to evaluate expectation values.</p>
</div></blockquote>
<p><strong>options</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.Qdeoptions</span></tt></p>
<blockquote>
<div><p>Options for the ODE solver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">output: <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></tt></p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></tt>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.floquet">
<span id="floquet-states-and-floquet-markov-master-equation"></span><h3>Floquet States and Floquet-Markov Master Equation<a class="headerlink" href="#module-qutip.floquet" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.floquet.fmmesolve">
<tt class="descname">fmmesolve</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>c_ops</em>, <em>e_ops=[]</em>, <em>spectra_cb=[]</em>, <em>T=None</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options instance at 0x105963290&gt;</em>, <em>floquet_basis=True</em>, <em>kmax=5</em><big>)</big><a class="reference internal" href="../modules/qutip/floquet.html#fmmesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.fmmesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the dynamics for the system using the Floquet-Markov master equation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This solver currently does not support multiple collapse operators.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0 / psi0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> / callback function</p>
<blockquote>
<div><p>list of operators for which to evaluate expectation values.</p>
</div></blockquote>
<p><strong>spectra_cb</strong> : list callback functions</p>
<blockquote>
<div><p>List of callback functions that compute the noise power spectrum as
a function of frequency for the collapse operators in <cite>c_ops</cite>.</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian. The default value
&#8216;None&#8217; indicates that the &#8216;tlist&#8217; spans a single period of the driving.</p>
</div></blockquote>
<p><strong>args</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
<p>This dictionary should also contain an entry &#8216;w_th&#8217;, which is
the temperature of the environment (if finite) in the
energy/frequency units of the Hamiltonian.  For example, if
the Hamiltonian written in units of 2pi GHz, and the
temperature is given in K, use the following conversion</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">temperature</span> <span class="o">=</span> <span class="mf">25e-3</span> <span class="c"># unit K</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="mf">6.626e-34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kB</span> <span class="o">=</span> <span class="mf">1.38e-23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">[</span><span class="s">&#39;w_th&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temperature</span> <span class="o">*</span> <span class="p">(</span><span class="n">kB</span> <span class="o">/</span> <span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="mf">1e-9</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>options</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></tt></p>
<blockquote>
<div><p>options for the ODE solver.</p>
</div></blockquote>
<p><strong>k_max</strong> : int</p>
<blockquote>
<div><p>The truncation of the number of sidebands (default 5).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></tt></p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></tt>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes">
<tt class="descname">floquet_modes</tt><big>(</big><em>H</em>, <em>T</em>, <em>args=None</em>, <em>sort=False</em>, <em>U=None</em><big>)</big><a class="reference internal" href="../modules/qutip/floquet.html#floquet_modes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the initial Floquet modes Phi_alpha(0) for a driven system with
period T.</p>
<p>Returns a list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> instances representing the Floquet
modes and a list of corresponding quasienergies, sorted by increasing
quasienergy in the interval [-pi/T, pi/T]. The optional parameter <cite>sort</cite>
decides if the output is to be sorted in increasing quasienergies or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian, time-dependent with period <cite>T</cite></p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>dictionary with variables required to evaluate H</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian. The default value
&#8216;None&#8217; indicates that the &#8216;tlist&#8217; spans a single period of the driving.</p>
</div></blockquote>
<p><strong>U</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>The propagator for the time-dependent Hamiltonian with period <cite>T</cite>.
If U is <cite>None</cite> (default), it will be calculated from the Hamiltonian
<cite>H</cite> using <a class="reference internal" href="#qutip.propagator.propagator" title="qutip.propagator.propagator"><tt class="xref py py-func docutils literal"><span class="pre">qutip.propagator.propagator</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : list of kets, list of quasi energies</p>
<blockquote class="last">
<div><p>Two lists: the Floquet modes as kets and the quasi energies.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes_t">
<tt class="descname">floquet_modes_t</tt><big>(</big><em>f_modes_0</em>, <em>f_energies</em>, <em>t</em>, <em>H</em>, <em>T</em>, <em>args=None</em><big>)</big><a class="reference internal" href="../modules/qutip/floquet.html#floquet_modes_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the
initial Floquet modes Phi_alpha(0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_modes_0</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> (kets)</p>
<blockquote>
<div><p>Floquet modes at <span class="math">\(t\)</span></p>
</div></blockquote>
<p><strong>f_energies</strong> : list</p>
<blockquote>
<div><p>Floquet energies.</p>
</div></blockquote>
<p><strong>t</strong> : float</p>
<blockquote>
<div><p>The time at which to evaluate the floquet modes.</p>
</div></blockquote>
<p><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian, time-dependent with period <cite>T</cite></p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>dictionary with variables required to evaluate H</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : list of kets</p>
<blockquote class="last">
<div><p>The Floquet modes as kets at time <span class="math">\(t\)</span></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes_table">
<tt class="descname">floquet_modes_table</tt><big>(</big><em>f_modes_0</em>, <em>f_energies</em>, <em>tlist</em>, <em>H</em>, <em>T</em>, <em>args=None</em><big>)</big><a class="reference internal" href="../modules/qutip/floquet.html#floquet_modes_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-calculate the Floquet modes for a range of times spanning the floquet
period. Can later be used as a table to look up the floquet modes for
any time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_modes_0</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> (kets)</p>
<blockquote>
<div><p>Floquet modes at <span class="math">\(t\)</span></p>
</div></blockquote>
<p><strong>f_energies</strong> : list</p>
<blockquote>
<div><p>Floquet energies.</p>
</div></blockquote>
<p><strong>tlist</strong> : array</p>
<blockquote>
<div><p>The list of times at which to evaluate the floquet modes.</p>
</div></blockquote>
<p><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian, time-dependent with period <cite>T</cite></p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>dictionary with variables required to evaluate H</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : nested list</p>
<blockquote class="last">
<div><p>A nested list of Floquet modes as kets for each time in <cite>tlist</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes_t_lookup">
<tt class="descname">floquet_modes_t_lookup</tt><big>(</big><em>f_modes_table_t</em>, <em>t</em>, <em>T</em><big>)</big><a class="reference internal" href="../modules/qutip/floquet.html#floquet_modes_t_lookup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes_t_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Lookup the floquet mode at time t in the pre-calculated table of floquet
modes in the first period of the time-dependence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_modes_table_t</strong> : nested list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> (kets)</p>
<blockquote>
<div><p>A lookup-table of Floquet modes at times precalculated by
<a class="reference internal" href="#qutip.floquet.floquet_modes_table" title="qutip.floquet.floquet_modes_table"><tt class="xref py py-func docutils literal"><span class="pre">qutip.floquet.floquet_modes_table</span></tt></a>.</p>
</div></blockquote>
<p><strong>t</strong> : float</p>
<blockquote>
<div><p>The time for which to evaluate the Floquet modes.</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : nested list</p>
<blockquote class="last">
<div><p>A list of Floquet modes as kets for the time that most closely matching
the time <cite>t</cite> in the supplied table of Floquet modes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_states_t">
<tt class="descname">floquet_states_t</tt><big>(</big><em>f_modes_0</em>, <em>f_energies</em>, <em>t</em>, <em>H</em>, <em>T</em>, <em>args=None</em><big>)</big><a class="reference internal" href="../modules/qutip/floquet.html#floquet_states_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_states_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the floquet states at time t given the initial Floquet modes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_modes_t</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> (kets)</p>
<blockquote>
<div><p>A list of initial Floquet modes (for time <span class="math">\(t=0\)</span>).</p>
</div></blockquote>
<p><strong>f_energies</strong> : array</p>
<blockquote>
<div><p>The Floquet energies.</p>
</div></blockquote>
<p><strong>t</strong> : float</p>
<blockquote>
<div><p>The time for which to evaluate the Floquet states.</p>
</div></blockquote>
<p><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>Dictionary with variables required to evaluate H.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : list</p>
<blockquote class="last">
<div><p>A list of Floquet states for the time <span class="math">\(t\)</span>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_wavefunction_t">
<tt class="descname">floquet_wavefunction_t</tt><big>(</big><em>f_modes_0</em>, <em>f_energies</em>, <em>f_coeff</em>, <em>t</em>, <em>H</em>, <em>T</em>, <em>args=None</em><big>)</big><a class="reference internal" href="../modules/qutip/floquet.html#floquet_wavefunction_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_wavefunction_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the wavefunction for a time t using the Floquet state
decompositon, given the initial Floquet modes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_modes_t</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> (kets)</p>
<blockquote>
<div><p>A list of initial Floquet modes (for time <span class="math">\(t=0\)</span>).</p>
</div></blockquote>
<p><strong>f_energies</strong> : array</p>
<blockquote>
<div><p>The Floquet energies.</p>
</div></blockquote>
<p><strong>f_coeff</strong> : array</p>
<blockquote>
<div><p>The coefficients for Floquet decomposition of the initial wavefunction.</p>
</div></blockquote>
<p><strong>t</strong> : float</p>
<blockquote>
<div><p>The time for which to evaluate the Floquet states.</p>
</div></blockquote>
<p><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>Dictionary with variables required to evaluate H.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote class="last">
<div><p>The wavefunction for the time <span class="math">\(t\)</span>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_state_decomposition">
<tt class="descname">floquet_state_decomposition</tt><big>(</big><em>f_states</em>, <em>f_energies</em>, <em>psi</em><big>)</big><a class="reference internal" href="../modules/qutip/floquet.html#floquet_state_decomposition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_state_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose the wavefunction <cite>psi</cite> (typically an initial state) in terms of
the Floquet states, <span class="math">\(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_states</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> (kets)</p>
<blockquote>
<div><p>A list of Floquet modes.</p>
</div></blockquote>
<p><strong>f_energies</strong> : array</p>
<blockquote>
<div><p>The Floquet energies.</p>
</div></blockquote>
<p><strong>psi</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>The wavefunction to decompose in the Floquet state basis.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : array</p>
<blockquote class="last">
<div><p>The coefficients <span class="math">\(c_\alpha\)</span> in the Floquet state decomposition.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.fsesolve">
<tt class="descname">fsesolve</tt><big>(</big><em>H</em>, <em>psi0</em>, <em>tlist</em>, <em>e_ops=[]</em>, <em>T=None</em>, <em>args={}</em>, <em>Tsteps=100</em><big>)</big><a class="reference internal" href="../modules/qutip/floquet.html#fsesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.fsesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the Schrodinger equation using the Floquet formalism.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</div></blockquote>
<p><strong>psi0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>Initial state vector (ket).</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> / callback function</p>
<blockquote>
<div><p>list of operators for which to evaluate expectation values. If this
list is empty, the state vectors for each time in <cite>tlist</cite> will be
returned instead of expectation values.</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>Dictionary with variables required to evaluate H.</p>
</div></blockquote>
<p><strong>Tsteps</strong> : integer</p>
<blockquote>
<div><p>The number of time steps in one driving period for which to
precalculate the Floquet modes. <cite>Tsteps</cite> should be an even number.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></tt></a></p>
<blockquote class="last">
<div><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></tt></a>, which
contains either an <em>array</em> of expectation values or an array of
state vectors, for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.stochastic">
<span id="stochastic-schrodinger-equation-and-master-equation"></span><h3>Stochastic Schrödinger Equation and Master Equation<a class="headerlink" href="#module-qutip.stochastic" title="Permalink to this headline">¶</a></h3>
<p>This module contains functions for solving stochastic schrodinger and master
equations. The API should not be considered stable, and is subject to change
when we work more on optimizing this module for performance and features.</p>
<dl class="function">
<dt id="qutip.stochastic.smesolve">
<tt class="descname">smesolve</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>times</em>, <em>c_ops</em>, <em>sc_ops</em>, <em>e_ops</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/qutip/stochastic.html#smesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.smesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve stochastic master equation. Dispatch to specific solvers
depending on the value of the <cite>solver</cite> keyword argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>times</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>. Must be uniformly spaced.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</div></blockquote>
<p><strong>sc_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a> / callback function single</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>kwargs</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><tt class="xref py py-class docutils literal"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">output: <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></tt></p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.stochastic.ssesolve">
<tt class="descname">ssesolve</tt><big>(</big><em>H</em>, <em>psi0</em>, <em>times</em>, <em>sc_ops</em>, <em>e_ops</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/qutip/stochastic.html#ssesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.ssesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the stochastic Schrödinger equation. Dispatch to specific solvers
depending on the value of the <cite>solver</cite> keyword argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>psi0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Initial state vector (ket).</p>
</div></blockquote>
<p><strong>times</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>. Must be uniformly spaced.</p>
</div></blockquote>
<p><strong>sc_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the equation of motion according to how the d1 and d2 functions
are defined.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>kwargs</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><tt class="xref py py-class docutils literal"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">output: <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></tt></p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.stochastic.smepdpsolve">
<tt class="descname">smepdpsolve</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>times</em>, <em>c_ops</em>, <em>e_ops</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/qutip/stochastic.html#smepdpsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.smepdpsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>A stochastic (piecewse deterministic process) PDP solver for density matrix
evolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Initial density matrix.</p>
</div></blockquote>
<p><strong>times</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>. Must be uniformly spaced.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</div></blockquote>
<p><strong>sc_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a> / callback function single</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>kwargs</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><tt class="xref py py-class docutils literal"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">output: <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></tt></p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.stochastic.ssepdpsolve">
<tt class="descname">ssepdpsolve</tt><big>(</big><em>H</em>, <em>psi0</em>, <em>times</em>, <em>c_ops</em>, <em>e_ops</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/qutip/stochastic.html#ssepdpsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.ssepdpsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>A stochastic (piecewse deterministic process) PDP solver for wavefunction
evolution. For most purposes, use <a class="reference internal" href="#module-qutip.mcsolve" title="qutip.mcsolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mcsolve</span></tt></a> instead for quantum
trajectory simulations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>psi0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Initial state vector (ket).</p>
</div></blockquote>
<p><strong>times</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>. Must be uniformly spaced.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a> / callback function single</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>kwargs</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><tt class="xref py py-class docutils literal"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">output: <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></tt></p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.correlation">
<span id="correlation-functions"></span><h3>Correlation Functions<a class="headerlink" href="#module-qutip.correlation" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.correlation.correlation">
<tt class="descname">correlation</tt><big>(</big><em>H</em>, <em>state0</em>, <em>tlist</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver='me'</em>, <em>reverse=False</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x105963a70&gt;</em><big>)</big><a class="reference internal" href="../modules/qutip/correlation.html#correlation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Calculate the two-operator two-time correlation function:
<span class="math">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<dl class="docutils">
<dt>state0 <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">Initial state density matrix <span class="math">\(\rho(t_0)\)</span> or state vector
<span class="math">\(\psi(t_0)\)</span>. If &#8216;state0&#8217; is &#8216;None&#8217;, then the steady state will
be used as the initial state. The &#8216;steady-state&#8217; is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt>tlist <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">list of times for <span class="math">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. :math:<a href="#id4"><span class="problematic" id="id5">`</span></a>t</p>
</dd>
</dl>
</div></blockquote>
<p><strong>ightarrow infty`; here tlist is</strong></p>
<blockquote>
<div><blockquote>
<div><p>automatically set, ignoring user input.</p>
</div></blockquote>
<dl class="docutils">
<dt>taulist <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt>c_ops <span class="classifier-delimiter">:</span> <span class="classifier">list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">list of collapse operators.</p>
</dd>
<dt>a_op <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt>b_op <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">operator B.</p>
</dd>
<dt>reverse <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If <cite>True</cite>, calculate <span class="math">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt>solver <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series)</p>
</dd>
<dt>options <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Options</span></tt></a></span></dt>
<dd><p class="first last">solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">corr_mat: <em>array</em></p>
<blockquote class="last">
<div><p>An 2-dimensional <em>array</em> (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional <em>array</em> of correlation values
is returned instead.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_ss">
<tt class="descname">correlation_ss</tt><big>(</big><em>H</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver='me'</em>, <em>reverse=False</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x105963a28&gt;</em><big>)</big><a class="reference internal" href="../modules/qutip/correlation.html#correlation_ss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:</p>
<div class="math">
\[\begin{split}\lim_{t         o \infty} \left&lt;A(t+\tau)B(t)\right&gt;\end{split}\]</div>
<p>along one time axis (given steady-state initial conditions) using the
quantum regression theorem and the evolution solver indicated by the
<cite>solver</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>taulist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>reverse</strong> : bool</p>
<blockquote>
<div><p>If <cite>True</cite>, calculate
<span class="math">\(\lim_{t  o \infty} \left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math">\(\lim_{t  o \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation and
<cite>es</cite> for exponential series)</p>
</div></blockquote>
<p><strong>options</strong> : <a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Options</span></tt></a></p>
<blockquote>
<div><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">corr_vec: <em>array</em></p>
<blockquote class="last">
<div><p>An <em>array</em> of correlation values for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_2op_1t">
<tt class="descname">correlation_2op_1t</tt><big>(</big><em>H</em>, <em>state0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver='me'</em>, <em>reverse=False</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x1059637e8&gt;</em><big>)</big><a class="reference internal" href="../modules/qutip/correlation.html#correlation_2op_1t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_2op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:
:math: <cite>left&lt;A(t+tau)B(t)right&gt;</cite>
along one time axis using the quantum regression theorem and the evolution
solver indicated by the <cite>solver</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>state0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Initial state density matrix <span class="math">\(\rho(t_0)\)</span> or state vector
<span class="math">\(\psi(t_0)\)</span>. If &#8216;state0&#8217; is &#8216;None&#8217;, then the steady state will
be used as the initial state. The &#8216;steady-state&#8217; is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</div></blockquote>
<p><strong>taulist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>reverse</strong> : bool</p>
<blockquote>
<div><p>If <cite>True</cite>, calculate <span class="math">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series)</p>
</div></blockquote>
<p><strong>options</strong> : <a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Options</span></tt></a></p>
<blockquote>
<div><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">corr_vec: <em>array</em></p>
<blockquote class="last">
<div><p>An <em>array</em> of correlation values for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_2op_2t">
<tt class="descname">correlation_2op_2t</tt><big>(</big><em>H</em>, <em>state0</em>, <em>tlist</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver='me'</em>, <em>reverse=False</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x1059638c0&gt;</em><big>)</big><a class="reference internal" href="../modules/qutip/correlation.html#correlation_2op_2t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_2op_2t" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Calculate the two-operator two-time correlation function:
<span class="math">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<dl class="docutils">
<dt>state0 <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">Initial state density matrix <span class="math">\(\rho_0\)</span> or state vector
<span class="math">\(\psi_0\)</span>. If &#8216;state0&#8217; is &#8216;None&#8217;, then the steady state will
be used as the initial state. The &#8216;steady-state&#8217; is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt>tlist <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">list of times for <span class="math">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. :math:<a href="#id6"><span class="problematic" id="id7">`</span></a>t</p>
</dd>
</dl>
</div></blockquote>
<p><strong>ightarrow infty`; here tlist is</strong></p>
<blockquote>
<div><blockquote>
<div><p>automatically set, ignoring user input.</p>
</div></blockquote>
<dl class="docutils">
<dt>taulist <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt>c_ops <span class="classifier-delimiter">:</span> <span class="classifier">list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">list of collapse operators.</p>
</dd>
<dt>a_op <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt>b_op <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">operator B.</p>
</dd>
<dt>reverse <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If <cite>True</cite>, calculate <span class="math">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt>solver <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series)</p>
</dd>
<dt>options <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Options</span></tt></a></span></dt>
<dd><p class="first last">solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">corr_mat: <em>array</em></p>
<blockquote class="last">
<div><p>An 2-dimensional <em>array</em> (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional <em>array</em> of correlation values
is returned instead.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_3op_1t">
<tt class="descname">correlation_3op_1t</tt><big>(</big><em>H</em>, <em>state0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>c_op</em>, <em>solver='me'</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x105963908&gt;</em><big>)</big><a class="reference internal" href="../modules/qutip/correlation.html#correlation_3op_1t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_3op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the three-operator two-time correlation function:
<span class="math">\(\left&lt;A(t)B(t+\tau)C(t)\right&gt;\)</span>
along one time axis using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where :math: <cite>tau&lt;0</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Initial state density matrix <span class="math">\(\rho(t_0)\)</span> or state vector
<span class="math">\(\psi(t_0)\)</span>. If &#8216;state0&#8217; is &#8216;None&#8217;, then the steady state will
be used as the initial state. The &#8216;steady-state&#8217; is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</div></blockquote>
<p><strong>taulist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>c_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator C.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series)</p>
</div></blockquote>
<p><strong>options</strong> : <a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Options</span></tt></a></p>
<blockquote>
<div><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">corr_vec: <em>array</em></p>
<blockquote class="last">
<div><p>An <em>array</em> of correlation values for the times specified by <cite>taulist</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_3op_2t">
<tt class="descname">correlation_3op_2t</tt><big>(</big><em>H</em>, <em>state0</em>, <em>tlist</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>c_op</em>, <em>solver='me'</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x105963950&gt;</em><big>)</big><a class="reference internal" href="../modules/qutip/correlation.html#correlation_3op_2t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_3op_2t" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculate the three-operator two-time correlation function:
<span class="math">\(\left&lt;A(t)B(t+\tau)C(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where :math: <cite>tau&lt;0</cite>.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><blockquote>
<div><p>system Hamiltonian, or a callback function for time-dependent
Hamiltonians.</p>
</div></blockquote>
<dl class="docutils">
<dt>rho0 <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">Initial state density matrix <span class="math">\(\rho_0\)</span> or state vector
<span class="math">\(\psi_0\)</span>. If &#8216;state0&#8217; is &#8216;None&#8217;, then the steady state will
be used as the initial state. The &#8216;steady-state&#8217; is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt>tlist <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">list of times for <span class="math">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. :math:<a href="#id8"><span class="problematic" id="id9">`</span></a>t</p>
</dd>
</dl>
</div></blockquote>
<p><strong>ightarrow infty`; here tlist is</strong></p>
<blockquote>
<div><blockquote>
<div><p>automatically set, ignoring user input.</p>
</div></blockquote>
<dl class="docutils">
<dt>taulist <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt>c_ops <span class="classifier-delimiter">:</span> <span class="classifier">list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">list of collapse operators. (does not accept time dependence)</p>
</dd>
<dt>a_op <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt>b_op <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">operator B.</p>
</dd>
<dt>c_op <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">operator C.</p>
</dd>
<dt>solver <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series)</p>
</dd>
<dt>options <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Options</span></tt></a></span></dt>
<dd><p class="first last">solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">corr_mat: <em>array</em></p>
<blockquote class="last">
<div><p>An 2-dimensional <em>array</em> (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional <em>array</em> of correlation values
is returned instead.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_4op_1t">
<tt class="descname">correlation_4op_1t</tt><big>(</big><em>H</em>, <em>state0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>c_op</em>, <em>d_op</em>, <em>solver='me'</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x105963ab8&gt;</em><big>)</big><a class="reference internal" href="../modules/qutip/correlation.html#correlation_4op_1t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_4op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the four-operator two-time correlation function:
<span class="math">\(\left&lt;A(t)B(t+\tau)C(t+\tau)D(t)\right&gt;\)</span>
along one time axis using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math">\(\tau&lt;0\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Initial state density matrix <span class="math">\(\rho(t_0)\)</span> or state vector
<span class="math">\(\psi(t_0)\)</span>. If &#8216;state0&#8217; is &#8216;None&#8217;, then the steady state will
be used as the initial state. The &#8216;steady-state&#8217; is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</div></blockquote>
<p><strong>taulist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>c_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator C.</p>
</div></blockquote>
<p><strong>d_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator D.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series)</p>
</div></blockquote>
<p><strong>options</strong> : <a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Options</span></tt></a></p>
<blockquote>
<div><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">corr_vec: <em>array</em></p>
<blockquote class="last">
<div><p>An <em>array</em> of correlation values for the times specified by <cite>taulist</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_4op_2t">
<tt class="descname">correlation_4op_2t</tt><big>(</big><em>H</em>, <em>state0</em>, <em>tlist</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>c_op</em>, <em>d_op</em>, <em>solver='me'</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x105963b00&gt;</em><big>)</big><a class="reference internal" href="../modules/qutip/correlation.html#correlation_4op_2t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_4op_2t" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculate the four-operator two-time correlation function:
<span class="math">\(\left&lt;A(t)B(t+\tau)C(t+\tau)D(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math">\(\tau&lt;0\)</span>.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><blockquote>
<div><p>system Hamiltonian, or a callback function for time-dependent
Hamiltonians.</p>
</div></blockquote>
<dl class="docutils">
<dt>rho0 <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">Initial state density matrix <span class="math">\(\rho_0\)</span> or state vector
<span class="math">\(\psi_0\)</span>. If &#8216;state0&#8217; is &#8216;None&#8217;, then the steady state will
be used as the initial state. The &#8216;steady-state&#8217; is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt>tlist <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">list of times for <span class="math">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. :math:<a href="#id10"><span class="problematic" id="id11">`</span></a>t</p>
</dd>
</dl>
</div></blockquote>
<p><strong>ightarrow infty`; here tlist is</strong></p>
<blockquote>
<div><blockquote>
<div><p>automatically set, ignoring user input.</p>
</div></blockquote>
<dl class="docutils">
<dt>taulist <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt>c_ops <span class="classifier-delimiter">:</span> <span class="classifier">list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">list of collapse operators. (does not accept time dependence)</p>
</dd>
<dt>a_op <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt>b_op <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">operator B.</p>
</dd>
<dt>c_op <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">operator C.</p>
</dd>
<dt>d_op <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></span></dt>
<dd><p class="first last">operator D.</p>
</dd>
<dt>solver <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series)</p>
</dd>
<dt>options <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Options</span></tt></a></span></dt>
<dd><p class="first last">solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">corr_mat: <em>array</em></p>
<blockquote class="last">
<div><p>An 2-dimensional <em>array</em> (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional <em>array</em> of correlation values
is returned instead.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum">
<tt class="descname">spectrum</tt><big>(</big><em>H</em>, <em>wlist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver='es'</em>, <em>use_pinv=False</em><big>)</big><a class="reference internal" href="../modules/qutip/correlation.html#spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math">\(\lim_{t      o \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math">
\[\begin{split}S(\omega) = \int_{-\infty}^{\infty}
\lim_{t         o \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\end{split}\]</div>
<p>using the solver indicated by the <cite>solver</cite> parameter. Note: this spectrum
is only defined for stationary statistics (uses steady state rho0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>wlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of frequencies for <span class="math">\(\omega\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>es</cite> for exponential series and
<cite>pi</cite> for psuedo-inverse)</p>
</div></blockquote>
<p><strong>use_pinv</strong> : bool</p>
<blockquote>
<div><p>For use with the <cite>pi</cite> solver: if <cite>True</cite> use numpy&#8217;s pinv method,
otherwise use a generic solver</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">spectrum: <em>array</em></p>
<blockquote class="last">
<div><p>An <em>array</em> with spectrum <span class="math">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum_ss">
<tt class="descname">spectrum_ss</tt><big>(</big><em>H</em>, <em>wlist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em><big>)</big><a class="reference internal" href="../modules/qutip/correlation.html#spectrum_ss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math">\(\lim_{t      o \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math">
\[\begin{split}S(\omega) = \int_{-\infty}^{\infty}
\lim_{t         o \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\end{split}\]</div>
<p>using an eseries based solver Note: this spectrum is only defined for
stationary statistics (uses steady state rho0).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>wlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of frequencies for <span class="math">\(\omega\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>use_pinv</strong> : bool</p>
<blockquote>
<div><p>If <cite>True</cite> use numpy&#8217;s <cite>pinv</cite> method, otherwise use a generic solver</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">spectrum: <em>array</em></p>
<blockquote class="last">
<div><p>An <em>array</em> with spectrum <span class="math">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum_pi">
<tt class="descname">spectrum_pi</tt><big>(</big><em>H</em>, <em>wlist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>use_pinv=False</em><big>)</big><a class="reference internal" href="../modules/qutip/correlation.html#spectrum_pi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum_pi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math">\(\lim_{t      o \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math">
\[\begin{split}S(\omega) = \int_{-\infty}^{\infty}
\lim_{t         o \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\end{split}\]</div>
<p>using a psuedo-inverse method. Note: this spectrum is only defined for
stationary statistics (uses steady state rho0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>wlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of frequencies for <span class="math">\(\omega\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>use_pinv</strong> : bool</p>
<blockquote>
<div><p>If <cite>True</cite> use numpy&#8217;s pinv method, otherwise use a generic solver</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">spectrum: <em>array</em></p>
<blockquote class="last">
<div><p>An <em>array</em> with spectrum <span class="math">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum_correlation_fft">
<tt class="descname">spectrum_correlation_fft</tt><big>(</big><em>taulist</em>, <em>y</em><big>)</big><a class="reference internal" href="../modules/qutip/correlation.html#spectrum_correlation_fft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum_correlation_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the power spectrum corresponding to a two-time correlation
function using FFT.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list/array of times <span class="math">\(t\)</span> which the correlation function is given.</p>
</div></blockquote>
<p><strong>y</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list/array of correlations corresponding to time delays <span class="math">\(t\)</span>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>w, S</strong> : <em>tuple</em></p>
<blockquote class="last">
<div><p>Returns an array of angular frequencies &#8216;w&#8217; and the corresponding
one-sided power spectrum &#8216;S(w)&#8217;.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.coherence_function_g1">
<tt class="descname">coherence_function_g1</tt><big>(</big><em>H</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>solver='me'</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x105963998&gt;</em><big>)</big><a class="reference internal" href="../modules/qutip/correlation.html#coherence_function_g1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.coherence_function_g1" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the normalized first-order quantum coherence function:</p>
<div class="math">
\[g^{(1)}(\tau) = \lim_{t         o \infty}
\frac{\langle a^\dagger(t+\tau)a(t)\rangle}
{\langle a^\dagger(t)a(t)\rangle}\]</div>
<p>using the quantum regression theorem and the evolution solver indicated by
the <cite>solver</cite> parameter. Note: g1 is only defined for stationary
statistics (uses steady state).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>taulist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>The annihilation operator of the mode.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation and
<cite>es</cite> for exponential series)</p>
</div></blockquote>
<p><strong>options</strong> : <a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Options</span></tt></a></p>
<blockquote>
<div><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">g1: <em>array</em></p>
<blockquote class="last">
<div><p>The normalized first-order coherence function.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.coherence_function_g2">
<tt class="descname">coherence_function_g2</tt><big>(</big><em>H</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>solver='me'</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x1059639e0&gt;</em><big>)</big><a class="reference internal" href="../modules/qutip/correlation.html#coherence_function_g2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.coherence_function_g2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the normalized second-order quantum coherence function:</p>
<div class="math">
\[g^{(2)}(\tau) = \lim_{t         o \infty}
\frac{\langle a^\dagger(t)a^\dagger(t+\tau)
a(t+\tau)a(t)\rangle}
{\langle a^\dagger(t)a(t)\rangle^2}\]</div>
<p>using the quantum regression theorem and the evolution solver indicated by
the <cite>solver</cite> parameter. Note: g2 is only defined for stationary
statistics (uses steady state rho0).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>taulist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>The annihilation operator of the mode.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation and
<cite>es</cite> for exponential series)</p>
</div></blockquote>
<p><strong>options</strong> : <a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Options</span></tt></a></p>
<blockquote>
<div><p>solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">g2: <em>array</em></p>
<blockquote class="last">
<div><p>The normalized second-order coherence function.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.steadystate">
<span id="steady-state-solvers"></span><h3>Steady-state Solvers<a class="headerlink" href="#module-qutip.steadystate" title="Permalink to this headline">¶</a></h3>
<p>Module contains functions for solving for the steady state density matrix of
open quantum systems defined by a Liouvillian or Hamiltonian and a list of
collapse operators.</p>
<dl class="function">
<dt id="qutip.steadystate.steadystate">
<tt class="descname">steadystate</tt><big>(</big><em>A</em>, <em>c_op_list=[]</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/qutip/steadystate.html#steadystate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.steadystate.steadystate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the steady state for quantum evolution subject to the
supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a
list of collapse operators.</p>
<p>If the user passes a Hamiltonian then it, along with the list of collapse
operators, will be converted into a Liouvillian operator in Lindblad form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>A Hamiltonian or Liouvillian operator.</p>
</div></blockquote>
<p><strong>c_op_list</strong> : list</p>
<blockquote>
<div><p>A list of collapse operators.</p>
</div></blockquote>
<p><strong>method</strong> : str {&#8216;direct&#8217;, &#8216;eigen&#8217;, &#8216;iterative-gmres&#8217;,</p>
<blockquote>
<div><blockquote>
<div><p>&#8216;iterative-lgmres&#8217;, &#8216;iterative-bicgstab&#8217;, &#8216;svd&#8217;, &#8216;power&#8217;}</p>
</div></blockquote>
<p>Method for solving the underlying linear equation. Direct LU solver
&#8216;direct&#8217; (default), sparse eigenvalue problem &#8216;eigen&#8217;,
iterative GMRES method &#8216;iterative-gmres&#8217;, iterative LGMRES method
&#8216;iterative-lgmres&#8217;, iterative BICGSTAB method &#8216;iterative-bicgstab&#8217;,</p>
<blockquote>
<div><p>SVD &#8216;svd&#8217; (dense), or inverse-power method &#8216;power&#8217;.</p>
</div></blockquote>
</div></blockquote>
<p><strong>return_info</strong> : bool, optional, default = False</p>
<blockquote>
<div><p>Return a dictionary of solver-specific infomation about the
solution and how it was obtained.</p>
</div></blockquote>
<p><strong>sparse</strong> : bool, optional, default = True</p>
<blockquote>
<div><p>Solve for the steady state using sparse algorithms. If set to False,
the underlying Liouvillian operator will be converted into a dense
matrix. Use only for &#8216;smaller&#8217; systems.</p>
</div></blockquote>
<p><strong>use_rcm</strong> : bool, optional, default = False</p>
<blockquote>
<div><p>Use reverse Cuthill-Mckee reordering to minimize fill-in in the
LU factorization of the Liouvillian.</p>
</div></blockquote>
<p><strong>use_wbm</strong> : bool, optional, default = False</p>
<blockquote>
<div><p>Use Weighted Bipartite Matching reordering to make the Liouvillian
diagonally dominant.  This is useful for iterative preconditioners
only, and is set to <tt class="docutils literal"><span class="pre">True</span></tt> by default when finding a preconditioner.</p>
</div></blockquote>
<p><strong>weight</strong> : float, optional</p>
<blockquote>
<div><p>Sets the size of the elements used for adding the unity trace condition
to the linear solvers.  This is set to the average abs value of the
Liouvillian elements if not specified by the user.</p>
</div></blockquote>
<p><strong>use_umfpack</strong> : bool {False, True}</p>
<blockquote>
<div><p>Use umfpack solver instead of SuperLU.  For SciPy 0.14+, this option
requires installing scikits.umfpack.</p>
</div></blockquote>
<p><strong>x0</strong> : ndarray, optional</p>
<blockquote>
<div><p>ITERATIVE ONLY. Initial guess for solution vector.</p>
</div></blockquote>
<p><strong>maxiter</strong> : int, optional, default=1000</p>
<blockquote>
<div><p>ITERATIVE ONLY. Maximum number of iterations to perform.</p>
</div></blockquote>
<p><strong>tol</strong> : float, optional, default=1e-9</p>
<blockquote>
<div><p>ITERATIVE ONLY. Tolerance used for terminating solver.</p>
</div></blockquote>
<p><strong>permc_spec</strong> : str, optional, default=&#8217;COLAMD&#8217;</p>
<blockquote>
<div><p>ITERATIVE ONLY. Column ordering used internally by superLU for the
&#8216;direct&#8217; LU decomposition method. Options include &#8216;COLAMD&#8217; and
&#8216;NATURAL&#8217;. If using RCM then this is set to &#8216;NATURAL&#8217; automatically
unless explicitly specified.</p>
</div></blockquote>
<p><strong>use_precond</strong> : bool optional, default = False</p>
<blockquote>
<div><p>ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a
preconditioner for the &#8216;iterative&#8217; GMRES and BICG solvers.
Speeds up convergence time by orders of magnitude in many cases.</p>
</div></blockquote>
<p><strong>M</strong> : {sparse matrix, dense matrix, LinearOperator}, optional</p>
<blockquote>
<div><p>ITERATIVE ONLY. Preconditioner for A. The preconditioner should
approximate the inverse of A. Effective preconditioning can
dramatically improve the rate of convergence for iterative methods.
If no preconditioner is given and <tt class="docutils literal"><span class="pre">use_precond</span> <span class="pre">=</span> <span class="pre">True</span></tt>, then one
is generated automatically.</p>
</div></blockquote>
<p><strong>fill_factor</strong> : float, optional, default = 100</p>
<blockquote>
<div><p>ITERATIVE ONLY. Specifies the fill ratio upper bound (&gt;=1) of the iLU
preconditioner.  Lower values save memory at the cost of longer
execution times and a possible singular factorization.</p>
</div></blockquote>
<p><strong>drop_tol</strong> : float, optional, default = 1e-4</p>
<blockquote>
<div><p>ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner
elements that should be dropped.  Can be reduced for a courser
factorization at the cost of an increased number of iterations, and a
possible singular factorization.</p>
</div></blockquote>
<p><strong>diag_pivot_thresh</strong> : float, optional, default = None</p>
<blockquote>
<div><p>ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal
elements are considered acceptable pivot points when using a
preconditioner.  A value of zero forces the pivot to be the diagonal
element.</p>
</div></blockquote>
<p><strong>ILU_MILU</strong> : str, optional, default = &#8216;smilu_2&#8217;</p>
<blockquote>
<div><p>ITERATIVE ONLY. Selects the incomplete LU decomposition method
algoithm used in creating the preconditoner. Should only be used by
advanced users.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote>
<div><p>Steady state density matrix.</p>
</div></blockquote>
<p><strong>info</strong> : dict, optional</p>
<blockquote class="last">
<div><p>Dictionary containing solver-specific information about the solution.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The SVD method works only for dense operators (i.e. small systems).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.steadystate.build_preconditioner">
<tt class="descname">build_preconditioner</tt><big>(</big><em>A</em>, <em>c_op_list=[]</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/qutip/steadystate.html#build_preconditioner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.steadystate.build_preconditioner" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a iLU preconditioner necessary for solving for
the steady state density matrix using the iterative linear solvers
in the &#8216;steadystate&#8217; function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>A Hamiltonian or Liouvillian operator.</p>
</div></blockquote>
<p><strong>c_op_list</strong> : list</p>
<blockquote>
<div><p>A list of collapse operators.</p>
</div></blockquote>
<p><strong>return_info</strong> : bool, optional, default = False</p>
<blockquote>
<div><p>Return a dictionary of solver-specific infomation about the
solution and how it was obtained.</p>
</div></blockquote>
<p><strong>use_rcm</strong> : bool, optional, default = False</p>
<blockquote>
<div><p>Use reverse Cuthill-Mckee reordering to minimize fill-in in the
LU factorization of the Liouvillian.</p>
</div></blockquote>
<p><strong>use_wbm</strong> : bool, optional, default = False</p>
<blockquote>
<div><p>Use Weighted Bipartite Matching reordering to make the Liouvillian
diagonally dominant.  This is useful for iterative preconditioners
only, and is set to <tt class="docutils literal"><span class="pre">True</span></tt> by default when finding a preconditioner.</p>
</div></blockquote>
<p><strong>weight</strong> : float, optional</p>
<blockquote>
<div><p>Sets the size of the elements used for adding the unity trace condition
to the linear solvers.  This is set to the average abs value of the
Liouvillian elements if not specified by the user.</p>
</div></blockquote>
<p><strong>permc_spec</strong> : str, optional, default=&#8217;COLAMD&#8217;</p>
<blockquote>
<div><p>Column ordering used internally by superLU for the
&#8216;direct&#8217; LU decomposition method. Options include &#8216;COLAMD&#8217; and
&#8216;NATURAL&#8217;. If using RCM then this is set to &#8216;NATURAL&#8217; automatically
unless explicitly specified.</p>
</div></blockquote>
<p><strong>fill_factor</strong> : float, optional, default = 100</p>
<blockquote>
<div><p>Specifies the fill ratio upper bound (&gt;=1) of the iLU
preconditioner.  Lower values save memory at the cost of longer
execution times and a possible singular factorization.</p>
</div></blockquote>
<p><strong>drop_tol</strong> : float, optional, default = 1e-4</p>
<blockquote>
<div><p>Sets the threshold for the magnitude of preconditioner
elements that should be dropped.  Can be reduced for a courser
factorization at the cost of an increased number of iterations, and a
possible singular factorization.</p>
</div></blockquote>
<p><strong>diag_pivot_thresh</strong> : float, optional, default = None</p>
<blockquote>
<div><p>Sets the threshold between [0,1] for which diagonal
elements are considered acceptable pivot points when using a
preconditioner.  A value of zero forces the pivot to be the diagonal
element.</p>
</div></blockquote>
<p><strong>ILU_MILU</strong> : str, optional, default = &#8216;smilu_2&#8217;</p>
<blockquote>
<div><p>Selects the incomplete LU decomposition method algoithm used in
creating the preconditoner. Should only be used by advanced users.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>lu</strong> : object</p>
<blockquote>
<div><p>Returns a SuperLU object representing iLU preconditioner.</p>
</div></blockquote>
<p><strong>info</strong> : dict, optional</p>
<blockquote class="last">
<div><p>Dictionary containing solver-specific information.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.propagator">
<span id="propagators"></span><h3>Propagators<a class="headerlink" href="#module-qutip.propagator" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.propagator.propagator">
<tt class="descname">propagator</tt><big>(</big><em>H</em>, <em>t</em>, <em>c_op_list</em>, <em>args=None</em>, <em>options=None</em>, <em>sparse=False</em>, <em>progress_bar=None</em><big>)</big><a class="reference internal" href="../modules/qutip/propagator.html#propagator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.propagator.propagator" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the propagator U(t) for the density matrix or wave function such
that <span class="math">\(\psi(t) = U(t)\psi(0)\)</span> or
<span class="math">\(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\)</span>
where <span class="math">\(\rho_{\mathrm vec}\)</span> is the vector representation of the
density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : qobj or list</p>
<blockquote>
<div><p>Hamiltonian as a Qobj instance of a nested list of Qobjs and
coefficients in the list-string or list-function format for
time-dependent Hamiltonians (see description in <a class="reference internal" href="#module-qutip.mesolve" title="qutip.mesolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mesolve</span></tt></a>).</p>
</div></blockquote>
<p><strong>t</strong> : float or array-like</p>
<blockquote>
<div><p>Time or list of times for which to evaluate the propagator.</p>
</div></blockquote>
<p><strong>c_op_list</strong> : list</p>
<blockquote>
<div><p>List of qobj collapse operators.</p>
</div></blockquote>
<p><strong>args</strong> : list/array/dictionary</p>
<blockquote>
<div><p>Parameters to callback functions for time-dependent Hamiltonians and
collapse operators.</p>
</div></blockquote>
<p><strong>options</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.Options</span></tt></p>
<blockquote>
<div><p>with options for the ODE solver.</p>
</div></blockquote>
<p><strong>progress_bar: BaseProgressBar</strong></p>
<blockquote>
<div><p>Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation. By default no progress bar
is used, and if set to True a TextProgressBar will be used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>a</strong> : qobj</p>
<blockquote class="last">
<div><p>Instance representing the propagator <span class="math">\(U(t)\)</span>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.propagator.propagator_steadystate">
<tt class="descname">propagator_steadystate</tt><big>(</big><em>U</em><big>)</big><a class="reference internal" href="../modules/qutip/propagator.html#propagator_steadystate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.propagator.propagator_steadystate" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the steady state for successive applications of the propagator
<span class="math">\(U\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : qobj</p>
<blockquote>
<div><p>Operator representing the propagator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>a</strong> : qobj</p>
<blockquote class="last">
<div><p>Instance representing the steady-state density matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip">
<span id="time-dependent-problems"></span><h3>Time-dependent problems<a class="headerlink" href="#module-qutip" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.rhs_generate">
<tt class="descname">rhs_generate</tt><big>(</big><em>H</em>, <em>c_ops</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options instance at 0x10569e200&gt;</em>, <em>name=None</em>, <em>cleanup=True</em><big>)</big><a class="headerlink" href="#qutip.rhs_generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the Cython functions needed for solving the dynamics of a
given system using the mesolve function inside a parfor loop.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : qobj</p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> of collapse operators.</p>
</div></blockquote>
<p><strong>args</strong> : dict</p>
<blockquote>
<div><p>Arguments for time-dependent Hamiltonian and collapse operator terms.</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>Instance of ODE solver options.</p>
</div></blockquote>
<p><strong>name: str</strong></p>
<blockquote>
<div><p>Name of generated RHS</p>
</div></blockquote>
<p><strong>cleanup: bool</strong></p>
<blockquote class="last">
<div><p>Whether the generated cython file should be automatically removed or
not.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Using this function with any solver other than the mesolve function
will result in an error.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.rhs_clear">
<tt class="descname">rhs_clear</tt><big>(</big><big>)</big><a class="headerlink" href="#qutip.rhs_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the string-format time-dependent Hamiltonian parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Nothing, just clears data from internal config module.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.wigner">
<span id="pseudoprobability-functions"></span><h3>Pseudoprobability Functions<a class="headerlink" href="#module-qutip.wigner" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.wigner.qfunc">
<tt class="descname">qfunc</tt><big>(</big><em>state</em>, <em>xvec</em>, <em>yvec</em>, <em>g=1.4142135623730951</em><big>)</big><a class="reference internal" href="../modules/qutip/wigner.html#qfunc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.wigner.qfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Q-function of a given state vector or density matrix
at points <cite>xvec + i * yvec</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote>
<div><p>A state vector or density matrix.</p>
</div></blockquote>
<p><strong>xvec</strong> : array_like</p>
<blockquote>
<div><p>x-coordinates at which to calculate the Wigner function.</p>
</div></blockquote>
<p><strong>yvec</strong> : array_like</p>
<blockquote>
<div><p>y-coordinates at which to calculate the Wigner function.</p>
</div></blockquote>
<p><strong>g</strong> : float</p>
<blockquote>
<div><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Q</strong> : array</p>
<blockquote class="last">
<div><p>Values representing the Q-function calculated over the specified range
[xvec,yvec].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.wigner.wigner">
<tt class="descname">wigner</tt><big>(</big><em>psi</em>, <em>xvec</em>, <em>yvec</em>, <em>method='iterative'</em>, <em>g=1.4142135623730951</em>, <em>parfor=False</em><big>)</big><a class="reference internal" href="../modules/qutip/wigner.html#wigner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.wigner.wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Wigner function for a state vector or density matrix at points
<cite>xvec + i * yvec</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote>
<div><p>A state vector or density matrix.</p>
</div></blockquote>
<p><strong>xvec</strong> : array_like</p>
<blockquote>
<div><p>x-coordinates at which to calculate the Wigner function.</p>
</div></blockquote>
<p><strong>yvec</strong> : array_like</p>
<blockquote>
<div><p>y-coordinates at which to calculate the Wigner function.  Does not
apply to the &#8216;fft&#8217; method.</p>
</div></blockquote>
<p><strong>g</strong> : float</p>
<blockquote>
<div><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.</p>
</div></blockquote>
<p><strong>method</strong> : string {&#8216;iterative&#8217;, &#8216;laguerre&#8217;, &#8216;fft&#8217;}</p>
<blockquote>
<div><p>Select method &#8216;iterative&#8217;, &#8216;laguerre&#8217;, or &#8216;fft&#8217;, where &#8216;iterative&#8217; uses
an iterative method to evaluate the Wigner functions for density
matrices <span class="math">\(|m&gt;&lt;n|\)</span>, while &#8216;laguerre&#8217; uses the Laguerre polynomials
in scipy for the same task. The &#8216;fft&#8217; method evaluates the Fourier
transform of the density matrix. The &#8216;iterative&#8217; method is default, and
in general recommended, but the &#8216;laguerre&#8217; method is more efficient for
very sparse density matrices (e.g., superpositions of Fock states in a
large Hilbert space). The &#8216;fft&#8217; method is the preferred method for
dealing with density matrices that have a large number of excitations
(&gt;~50).</p>
</div></blockquote>
<p><strong>parfor</strong> : bool {False, True}</p>
<blockquote>
<div><p>Flag for calculating the Laguerre polynomial based Wigner function
method=&#8217;laguerre&#8217; in parallel using the parfor function.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>W</strong> : array</p>
<blockquote>
<div><p>Values representing the Wigner function calculated over the specified
range [xvec,yvec].</p>
</div></blockquote>
<p><strong>yvex</strong> : array</p>
<blockquote class="last">
<div><p>FFT ONLY. Returns the y-coordinate values calculated via the Fourier
transform.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The &#8216;fft&#8217; method accepts only an xvec input for the x-coordinate.
The y-coordinates are calculated internally.</p>
<p class="rubric">References</p>
<p>Ulf Leonhardt,
Measuring the Quantum State of Light, (Cambridge University Press, 1997)</p>
</dd></dl>

</div>
<div class="section" id="graphs-and-visualization">
<h3>Graphs and Visualization<a class="headerlink" href="#graphs-and-visualization" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-qutip.visualization"></span><p>Functions for visualizing results of quantum dynamics simulations,
visualizations of quantum states and processes.</p>
<dl class="function">
<dt id="qutip.visualization.hinton">
<tt class="descname">hinton</tt><big>(</big><em>rho</em>, <em>xlabels=None</em>, <em>ylabels=None</em>, <em>title=None</em>, <em>ax=None</em>, <em>cmap=None</em>, <em>label_top=True</em><big>)</big><a class="reference internal" href="../modules/qutip/visualization.html#hinton"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.hinton" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a Hinton diagram for visualizing a density matrix or superoperator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : qobj</p>
<blockquote>
<div><p>Input density matrix or superoperator.</p>
</div></blockquote>
<p><strong>xlabels</strong> : list of strings or False</p>
<blockquote>
<div><p>list of x labels</p>
</div></blockquote>
<p><strong>ylabels</strong> : list of strings or False</p>
<blockquote>
<div><p>list of y labels</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>title of the plot (optional)</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>cmap</strong> : a matplotlib colormap instance</p>
<blockquote>
<div><p>Color map to use when plotting.</p>
</div></blockquote>
<p><strong>label_top</strong> : bool</p>
<blockquote>
<div><p>If True, x-axis labels will be placed on top, otherwise
they will appear below the plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote>
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>Input argument is not a quantum object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.matrix_histogram">
<tt class="descname">matrix_histogram</tt><big>(</big><em>M</em>, <em>xlabels=None</em>, <em>ylabels=None</em>, <em>title=None</em>, <em>limits=None</em>, <em>colorbar=True</em>, <em>fig=None</em>, <em>ax=None</em><big>)</big><a class="reference internal" href="../modules/qutip/visualization.html#matrix_histogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.matrix_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a histogram for the matrix M, with the given x and y labels and title.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>M</strong> : Matrix of Qobj</p>
<blockquote>
<div><p>The matrix to visualize</p>
</div></blockquote>
<p><strong>xlabels</strong> : list of strings</p>
<blockquote>
<div><p>list of x labels</p>
</div></blockquote>
<p><strong>ylabels</strong> : list of strings</p>
<blockquote>
<div><p>list of y labels</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>title of the plot (optional)</p>
</div></blockquote>
<p><strong>limits</strong> : list/array with two float numbers</p>
<blockquote>
<div><p>The z-axis limits [min, max] (optional)</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote>
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>Input argument is not valid.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.matrix_histogram_complex">
<tt class="descname">matrix_histogram_complex</tt><big>(</big><em>M</em>, <em>xlabels=None</em>, <em>ylabels=None</em>, <em>title=None</em>, <em>limits=None</em>, <em>phase_limits=None</em>, <em>colorbar=True</em>, <em>fig=None</em>, <em>ax=None</em>, <em>threshold=None</em><big>)</big><a class="reference internal" href="../modules/qutip/visualization.html#matrix_histogram_complex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.matrix_histogram_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a histogram for the amplitudes of matrix M, using the argument
of each element for coloring the bars, with the given x and y labels
and title.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>M</strong> : Matrix of Qobj</p>
<blockquote>
<div><p>The matrix to visualize</p>
</div></blockquote>
<p><strong>xlabels</strong> : list of strings</p>
<blockquote>
<div><p>list of x labels</p>
</div></blockquote>
<p><strong>ylabels</strong> : list of strings</p>
<blockquote>
<div><p>list of y labels</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>title of the plot (optional)</p>
</div></blockquote>
<p><strong>limits</strong> : list/array with two float numbers</p>
<blockquote>
<div><p>The z-axis limits [min, max] (optional)</p>
</div></blockquote>
<p><strong>phase_limits</strong> : list/array with two float numbers</p>
<blockquote>
<div><p>The phase-axis (colorbar) limits [min, max] (optional)</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>threshold: float (None)</strong></p>
<blockquote>
<div><p>Threshold for when bars of smaller height should be transparent. If
not set, all bars are colored according to the color map.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote>
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>Input argument is not valid.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_energy_levels">
<tt class="descname">plot_energy_levels</tt><big>(</big><em>H_list</em>, <em>N=0</em>, <em>labels=None</em>, <em>show_ylabels=False</em>, <em>figsize=(8</em>, <em>12)</em>, <em>fig=None</em>, <em>ax=None</em><big>)</big><a class="reference internal" href="../modules/qutip/visualization.html#plot_energy_levels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_energy_levels" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the energy level diagrams for a list of Hamiltonians. Include
up to N energy levels. For each element in H_list, the energy
levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,
where n is the index of an element in H_list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H_list</strong> : List of Qobj</p>
<blockquote>
<div><blockquote>
<div><p>A list of Hamiltonians.</p>
</div></blockquote>
<dl class="docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">List of string</span></dt>
<dd><p class="first last">A list of labels for each Hamiltonian</p>
</dd>
<dt>show_ylabels <span class="classifier-delimiter">:</span> <span class="classifier">Bool (default False)</span></dt>
<dd><p class="first last">Show y labels to the left of energy levels of the initial
Hamiltonian.</p>
</dd>
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of energy levels to plot</p>
</dd>
<dt>figsize <span class="classifier-delimiter">:</span> <span class="classifier">tuple (int,int)</span></dt>
<dd><p class="first last">The size of the figure (width, height).</p>
</dd>
<dt>fig <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib Figure instance</span></dt>
<dd><p class="first last">The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt>ax <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib axes instance</span></dt>
<dd><p class="first last">The axes context in which the plot will be drawn.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote>
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>Input argument is not valid.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_fock_distribution">
<tt class="descname">plot_fock_distribution</tt><big>(</big><em>rho</em>, <em>offset=0</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>6)</em>, <em>title=None</em>, <em>unit_y_range=True</em><big>)</big><a class="reference internal" href="../modules/qutip/visualization.html#plot_fock_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_fock_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the Fock distribution for a density matrix (or ket) that describes
an oscillator mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>The density matrix (or ket) of the state to visualize.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib Figure instance</p>
<blockquote>
<div><p>The Figure canvas in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>An optional title for the figure.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no &#8216;fig&#8217; and &#8216;ax&#8217; arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_wigner_fock_distribution">
<tt class="descname">plot_wigner_fock_distribution</tt><big>(</big><em>rho</em>, <em>fig=None</em>, <em>axes=None</em>, <em>figsize=(8</em>, <em>4)</em>, <em>cmap=None</em>, <em>alpha_max=7.5</em>, <em>colorbar=False</em>, <em>method='iterative'</em>, <em>projection='2d'</em><big>)</big><a class="reference internal" href="../modules/qutip/visualization.html#plot_wigner_fock_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_wigner_fock_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the Fock distribution and the Wigner function for a density matrix
(or ket) that describes an oscillator mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>The density matrix (or ket) of the state to visualize.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib Figure instance</p>
<blockquote>
<div><p>The Figure canvas in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>axes</strong> : a list of two matplotlib axes instances</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no &#8216;fig&#8217; and &#8216;ax&#8217; arguments are passed).</p>
</div></blockquote>
<p><strong>cmap</strong> : a matplotlib cmap instance</p>
<blockquote>
<div><p>The colormap.</p>
</div></blockquote>
<p><strong>alpha_max</strong> : float</p>
<blockquote>
<div><p>The span of the x and y coordinates (both [-alpha_max, alpha_max]).</p>
</div></blockquote>
<p><strong>colorbar</strong> : bool</p>
<blockquote>
<div><p>Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</div></blockquote>
<p><strong>method</strong> : string {&#8216;iterative&#8217;, &#8216;laguerre&#8217;, &#8216;fft&#8217;}</p>
<blockquote>
<div><p>The method used for calculating the wigner function. See the
documentation for qutip.wigner for details.</p>
</div></blockquote>
<p><strong>projection: string {&#8216;2d&#8217;, &#8216;3d&#8217;}</strong></p>
<blockquote>
<div><p>Specify whether the Wigner function is to be plotted as a
contour graph (&#8216;2d&#8217;) or surface plot (&#8216;3d&#8217;).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_wigner">
<tt class="descname">plot_wigner</tt><big>(</big><em>rho</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>4)</em>, <em>cmap=None</em>, <em>alpha_max=7.5</em>, <em>colorbar=False</em>, <em>method='iterative'</em>, <em>projection='2d'</em><big>)</big><a class="reference internal" href="../modules/qutip/visualization.html#plot_wigner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the the Wigner function for a density matrix (or ket) that describes
an oscillator mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>The density matrix (or ket) of the state to visualize.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib Figure instance</p>
<blockquote>
<div><p>The Figure canvas in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no &#8216;fig&#8217; and &#8216;ax&#8217; arguments are passed).</p>
</div></blockquote>
<p><strong>cmap</strong> : a matplotlib cmap instance</p>
<blockquote>
<div><p>The colormap.</p>
</div></blockquote>
<p><strong>alpha_max</strong> : float</p>
<blockquote>
<div><p>The span of the x and y coordinates (both [-alpha_max, alpha_max]).</p>
</div></blockquote>
<p><strong>colorbar</strong> : bool</p>
<blockquote>
<div><p>Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</div></blockquote>
<p><strong>method</strong> : string {&#8216;iterative&#8217;, &#8216;laguerre&#8217;, &#8216;fft&#8217;}</p>
<blockquote>
<div><p>The method used for calculating the wigner function. See the
documentation for qutip.wigner for details.</p>
</div></blockquote>
<p><strong>projection: string {&#8216;2d&#8217;, &#8216;3d&#8217;}</strong></p>
<blockquote>
<div><p>Specify whether the Wigner function is to be plotted as a
contour graph (&#8216;2d&#8217;) or surface plot (&#8216;3d&#8217;).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.sphereplot">
<tt class="descname">sphereplot</tt><big>(</big><em>theta</em>, <em>phi</em>, <em>values</em>, <em>fig=None</em>, <em>ax=None</em>, <em>save=False</em><big>)</big><a class="reference internal" href="../modules/qutip/visualization.html#sphereplot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.sphereplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a matrix of values on a sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : float</p>
<blockquote>
<div><p>Angle with respect to z-axis</p>
</div></blockquote>
<p><strong>phi</strong> : float</p>
<blockquote>
<div><p>Angle in x-y plane</p>
</div></blockquote>
<p><strong>values</strong> : array</p>
<blockquote>
<div><p>Data set to be plotted</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib Figure instance</p>
<blockquote>
<div><p>The Figure canvas in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>save</strong> : bool {False , True}</p>
<blockquote>
<div><p>Whether to save the figure or not</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_schmidt">
<tt class="descname">plot_schmidt</tt><big>(</big><em>ket</em>, <em>splitting=None</em>, <em>labels_iteration=(3</em>, <em>2)</em>, <em>theme='light'</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(6</em>, <em>6)</em><big>)</big><a class="reference internal" href="../modules/qutip/visualization.html#plot_schmidt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_schmidt" title="Permalink to this definition">¶</a></dt>
<dd><p>Plotting scheme related to Schmidt decomposition.
Converts a state into a matrix (A_ij -&gt; A_i^j),
where rows are first particles and columns - last.</p>
<p>See also: plot_qubism with how=&#8217;before_after&#8217; for a similar plot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ket</strong> : Qobj</p>
<blockquote>
<div><p>Pure state for plotting.</p>
</div></blockquote>
<p><strong>splitting</strong> : int</p>
<blockquote>
<div><p>Plot for a number of first particles versus the rest.
If not given, it is (number of particles + 1) // 2.</p>
</div></blockquote>
<p><strong>theme</strong> : &#8216;light&#8217; (default) or &#8216;dark&#8217;</p>
<blockquote>
<div><p>Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</div></blockquote>
<p><strong>labels_iteration</strong> : int or pair of ints (default (3,2))</p>
<blockquote>
<div><p>Number of particles to be shown as tick labels,
for first (vertical) and last (horizontal) particles, respectively.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib figure instance</p>
<blockquote>
<div><p>The figure canvas on which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axis instance</p>
<blockquote>
<div><p>The axis context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no &#8216;fig&#8217; and &#8216;ax&#8217; arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_qubism">
<tt class="descname">plot_qubism</tt><big>(</big><em>ket</em>, <em>theme='light'</em>, <em>how='pairs'</em>, <em>grid_iteration=1</em>, <em>legend_iteration=0</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(6</em>, <em>6)</em><big>)</big><a class="reference internal" href="../modules/qutip/visualization.html#plot_qubism"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_qubism" title="Permalink to this definition">¶</a></dt>
<dd><p>Qubism plot for pure states of many qudits.
Works best for spin chains, especially with even number of particles
of the same dimension.
Allows to see entanglement between first 2*k particles and the rest.</p>
<dl class="docutils">
<dt>More information:</dt>
<dd>J. Rodriguez-Laguna, P. Migdal,
M. Ibanez Berganza, M. Lewenstein, G. Sierra,
&#8220;Qubism: self-similar visualization of many-body wavefunctions&#8221;,
New J. Phys. 14 053028 (2012), arXiv:1112.3560,
http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ket</strong> : Qobj</p>
<blockquote>
<div><p>Pure state for plotting.</p>
</div></blockquote>
<p><strong>theme</strong> : &#8216;light&#8217; (default) or &#8216;dark&#8217;</p>
<blockquote>
<div><p>Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</div></blockquote>
<p><strong>how</strong> : &#8216;pairs&#8217; (default), &#8216;pairs_skewed&#8217; or &#8216;before_after&#8217;</p>
<blockquote>
<div><p>Type of Qubism plotting.
Options:</p>
<blockquote>
<div><p>&#8216;pairs&#8217; - typical coordinates,
&#8216;pairs_skewed&#8217; - for ferromagnetic/antriferromagnetic plots,
&#8216;before_after&#8217; - related to Schmidt plot (see also: plot_schmidt).</p>
</div></blockquote>
</div></blockquote>
<p><strong>grid_iteration</strong> : int (default 1)</p>
<blockquote>
<div><p>Helper lines to be drawn on plot.
Show tiles for 2*grid_iteration particles vs all others.</p>
</div></blockquote>
<p><strong>legend_iteration</strong> : int (default 0) or &#8216;grid_iteration&#8217; or &#8216;all&#8217;</p>
<blockquote>
<div><p>Show labels for first 2*legend_iteration particles.
Option &#8216;grid_iteration&#8217; sets the same number of particles</p>
<blockquote>
<div><p>as for grid_iteration.</p>
</div></blockquote>
<p>Option &#8216;all&#8217; makes label for all particles.
Typically it should be 0, 1, 2 or perhaps 3.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib figure instance</p>
<blockquote>
<div><p>The figure canvas on which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axis instance</p>
<blockquote>
<div><p>The axis context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no &#8216;fig&#8217; and &#8216;ax&#8217; arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_expectation_values">
<tt class="descname">plot_expectation_values</tt><big>(</big><em>results</em>, <em>ylabels=[]</em>, <em>title=None</em>, <em>show_legend=False</em>, <em>fig=None</em>, <em>axes=None</em>, <em>figsize=(8</em>, <em>4)</em><big>)</big><a class="reference internal" href="../modules/qutip/visualization.html#plot_expectation_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_expectation_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the results (expectation values) for an evolution solver.
<cite>results</cite> is assumed to be an instance of Result, or a list of Result
instances.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>results</strong> : (list of) <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></tt></a></p>
<blockquote>
<div><p>List of results objects returned by any of the QuTiP evolution solvers.</p>
</div></blockquote>
<p><strong>ylabels</strong> : list of strings</p>
<blockquote>
<div><p>The y-axis labels. List should be of the same length as <cite>results</cite>.</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>The title of the figure.</p>
</div></blockquote>
<p><strong>show_legend</strong> : bool</p>
<blockquote>
<div><p>Whether or not to show the legend.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib Figure instance</p>
<blockquote>
<div><p>The Figure canvas in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>axes</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no &#8216;fig&#8217; and &#8216;ax&#8217; arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_spin_distribution_2d">
<tt class="descname">plot_spin_distribution_2d</tt><big>(</big><em>P</em>, <em>THETA</em>, <em>PHI</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>8)</em><big>)</big><a class="reference internal" href="../modules/qutip/visualization.html#plot_spin_distribution_2d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_spin_distribution_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a spin distribution function (given as meshgrid data) with a 2D
projection where the surface of the unit sphere is mapped on the unit disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>P</strong> : matrix</p>
<blockquote>
<div><p>Distribution values as a meshgrid matrix.</p>
</div></blockquote>
<p><strong>THETA</strong> : matrix</p>
<blockquote>
<div><p>Meshgrid matrix for the theta coordinate.</p>
</div></blockquote>
<p><strong>PHI</strong> : matrix</p>
<blockquote>
<div><p>Meshgrid matrix for the phi coordinate.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib figure instance</p>
<blockquote>
<div><p>The figure canvas on which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axis instance</p>
<blockquote>
<div><p>The axis context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no &#8216;fig&#8217; and &#8216;ax&#8217; arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_spin_distribution_3d">
<tt class="descname">plot_spin_distribution_3d</tt><big>(</big><em>P</em>, <em>THETA</em>, <em>PHI</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>6)</em><big>)</big><a class="reference internal" href="../modules/qutip/visualization.html#plot_spin_distribution_3d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_spin_distribution_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a matrix of values on a sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>P</strong> : matrix</p>
<blockquote>
<div><p>Distribution values as a meshgrid matrix.</p>
</div></blockquote>
<p><strong>THETA</strong> : matrix</p>
<blockquote>
<div><p>Meshgrid matrix for the theta coordinate.</p>
</div></blockquote>
<p><strong>PHI</strong> : matrix</p>
<blockquote>
<div><p>Meshgrid matrix for the phi coordinate.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib figure instance</p>
<blockquote>
<div><p>The figure canvas on which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axis instance</p>
<blockquote>
<div><p>The axis context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no &#8216;fig&#8217; and &#8216;ax&#8217; arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-qutip"></span><dl class="function">
<dt id="qutip.orbital">
<tt class="descname">orbital</tt><big>(</big><em>theta</em>, <em>phi</em>, <em>*args</em><big>)</big><a class="headerlink" href="#qutip.orbital" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates an angular wave function on a sphere.
<tt class="docutils literal"><span class="pre">psi</span> <span class="pre">=</span> <span class="pre">orbital(theta,phi,ket1,ket2,...)</span></tt> calculates
the angular wave function on a sphere at the mesh of points
defined by theta and phi which is
<span class="math">\(\sum_{lm} c_{lm} Y_{lm}(theta,phi)\)</span> where <span class="math">\(C_{lm}\)</span> are the
coefficients specified by the list of kets. Each ket has 2l+1 components
for some integer l.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : list/array</p>
<blockquote>
<div><p>Polar angles</p>
</div></blockquote>
<p><strong>phi</strong> : list/array</p>
<blockquote>
<div><p>Azimuthal angles</p>
</div></blockquote>
<p><strong>args</strong> : list/array</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> of ket vectors.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><tt class="docutils literal"><span class="pre">array</span></tt> for angular wave function</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.tomography">
<span id="quantum-process-tomography"></span><h3>Quantum Process Tomography<a class="headerlink" href="#module-qutip.tomography" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.tomography.qpt">
<tt class="descname">qpt</tt><big>(</big><em>U</em>, <em>op_basis_list</em><big>)</big><a class="reference internal" href="../modules/qutip/tomography.html#qpt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tomography.qpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the quantum process tomography chi matrix for a given (possibly
nonunitary) transformation matrix U, which transforms a density matrix in
vector form according to:</p>
<blockquote>
<div><p>vec(rho) = U * vec(rho0)</p>
<p>or</p>
<p>rho = vec2mat(U * mat2vec(rho0))</p>
</div></blockquote>
<p>U can be calculated for an open quantum system using the QuTiP propagator
function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>Transformation operator. Can be calculated using QuTiP propagator
function.</p>
</div></blockquote>
<p><strong>op_basis_list</strong> : list</p>
<blockquote>
<div><p>A list of Qobj&#8217;s representing the basis states.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>chi</strong> : array</p>
<blockquote class="last">
<div><p>QPT chi matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.tomography.qpt_plot">
<tt class="descname">qpt_plot</tt><big>(</big><em>chi</em>, <em>lbls_list</em>, <em>title=None</em>, <em>fig=None</em>, <em>axes=None</em><big>)</big><a class="reference internal" href="../modules/qutip/tomography.html#qpt_plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tomography.qpt_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the quantum process tomography chi matrix. Plot the real and
imaginary parts separately.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chi</strong> : array</p>
<blockquote>
<div><p>Input QPT chi matrix.</p>
</div></blockquote>
<p><strong>lbls_list</strong> : list</p>
<blockquote>
<div><p>List of labels for QPT plot axes.</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>Plot title.</p>
</div></blockquote>
<p><strong>fig</strong> : figure instance</p>
<blockquote>
<div><p>User defined figure instance used for generating QPT plot.</p>
</div></blockquote>
<p><strong>axes</strong> : list of figure axis instance</p>
<blockquote>
<div><p>User defined figure axis instance (list of two axes) used for
generating QPT plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.tomography.qpt_plot_combined">
<tt class="descname">qpt_plot_combined</tt><big>(</big><em>chi</em>, <em>lbls_list</em>, <em>title=None</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>6)</em>, <em>threshold=None</em><big>)</big><a class="reference internal" href="../modules/qutip/tomography.html#qpt_plot_combined"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tomography.qpt_plot_combined" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the quantum process tomography chi matrix. Plot bars with
height and color corresponding to the absolute value and phase,
respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chi</strong> : array</p>
<blockquote>
<div><p>Input QPT chi matrix.</p>
</div></blockquote>
<p><strong>lbls_list</strong> : list</p>
<blockquote>
<div><p>List of labels for QPT plot axes.</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>Plot title.</p>
</div></blockquote>
<p><strong>fig</strong> : figure instance</p>
<blockquote>
<div><p>User defined figure instance used for generating QPT plot.</p>
</div></blockquote>
<p><strong>ax</strong> : figure axis instance</p>
<blockquote>
<div><p>User defined figure axis instance used for generating QPT plot
(alternative to the fig argument).</p>
</div></blockquote>
<p><strong>threshold: float (None)</strong></p>
<blockquote>
<div><p>Threshold for when bars of smaller height should be transparent. If
not set, all bars are colored according to the color map.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="quantum-information-processing">
<span id="functions-qip"></span><h2>Quantum Information Processing<a class="headerlink" href="#quantum-information-processing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.qip.gates">
<span id="gates"></span><h3>Gates<a class="headerlink" href="#module-qutip.qip.gates" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.qip.gates.rx">
<tt class="descname">rx</tt><big>(</big><em>phi</em>, <em>N=None</em>, <em>target=0</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#rx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.rx" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmax with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object for operator describing the rotation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.ry">
<tt class="descname">ry</tt><big>(</big><em>phi</em>, <em>N=None</em>, <em>target=0</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#ry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.ry" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmay with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object for operator describing the rotation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.rz">
<tt class="descname">rz</tt><big>(</big><em>phi</em>, <em>N=None</em>, <em>target=0</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#rz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.rz" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmaz with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object for operator describing the rotation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.sqrtnot">
<tt class="descname">sqrtnot</tt><big>(</big><em>N=None</em>, <em>target=0</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#sqrtnot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.sqrtnot" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit square root NOT gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object for operator describing the square root NOT gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.snot">
<tt class="descname">snot</tt><big>(</big><em>N=None</em>, <em>target=0</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#snot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.snot" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SNOT (Hadamard) gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>snot_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of SNOT gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snot</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.70710678+0.j  0.70710678+0.j]</span>
<span class="go"> [ 0.70710678+0.j -0.70710678+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.phasegate">
<tt class="descname">phasegate</tt><big>(</big><em>theta</em>, <em>N=None</em>, <em>target=0</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#phasegate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.phasegate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the phase shift gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : float</p>
<blockquote>
<div><p>Phase rotation angle.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>phase_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of phase shift gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">phasegate</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.00000000+0.j          0.00000000+0.j        ]</span>
<span class="go"> [ 0.00000000+0.j          0.70710678+0.70710678j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.cphase">
<tt class="descname">cphase</tt><big>(</big><em>theta</em>, <em>N=2</em>, <em>control=0</em>, <em>target=1</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#cphase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.cphase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the phase shift gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : float</p>
<blockquote>
<div><p>Phase rotation angle.</p>
</div></blockquote>
<p><strong>N</strong> : integer</p>
<blockquote>
<div><p>The number of qubits in the target space.</p>
</div></blockquote>
<p><strong>control</strong> : integer</p>
<blockquote>
<div><p>The index of the control qubit.</p>
</div></blockquote>
<p><strong>target</strong> : integer</p>
<blockquote>
<div><p>The index of the target qubit.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>U</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of controlled phase gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.cnot">
<tt class="descname">cnot</tt><big>(</big><em>N=None</em>, <em>control=0</em>, <em>target=1</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#cnot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.cnot" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the CNOT gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cnot_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of CNOT gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cnot</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.csign">
<tt class="descname">csign</tt><big>(</big><em>N=None</em>, <em>control=0</em>, <em>target=1</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#csign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.csign" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the CSIGN gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>csign_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of CSIGN gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">csign</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  -1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.berkeley">
<tt class="descname">berkeley</tt><big>(</big><em>N=None, targets=[0, 1]</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#berkeley"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.berkeley" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Berkeley gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>berkeley_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of Berkeley gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">berkeley</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ cos(pi/8).+0.j  0.+0.j           0.+0.j           0.+sin(pi/8).j]</span>
<span class="go">     [ 0.+0.j          cos(3pi/8).+0.j  0.+sin(3pi/8).j  0.+0.j]</span>
<span class="go">     [ 0.+0.j          0.+sin(3pi/8).j  cos(3pi/8).+0.j  0.+0.j]</span>
<span class="go">     [ 0.+sin(pi/8).j  0.+0.j           0.+0.j           cos(pi/8).+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.swapalpha">
<tt class="descname">swapalpha</tt><big>(</big><em>alpha, N=None, targets=[0, 1]</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#swapalpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.swapalpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SWAPalpha gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>swapalpha_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of SWAPalpha gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">swapalpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j                    0.+0.j                    0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.5*(1 + exp(j*pi*alpha)  0.5*(1 - exp(j*pi*alpha)  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.5*(1 - exp(j*pi*alpha)  0.5*(1 + exp(j*pi*alpha)  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j                    0.+0.j                    1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.swap">
<tt class="descname">swap</tt><big>(</big><em>N=None, targets=[0, 1]</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#swap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>swap_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of SWAP gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">swap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.iswap">
<tt class="descname">iswap</tt><big>(</big><em>N=None, targets=[0, 1]</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#iswap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.iswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the iSWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>iswap_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of iSWAP gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">iswap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+1.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+1.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.sqrtswap">
<tt class="descname">sqrtswap</tt><big>(</big><em>N=None, targets=[0, 1]</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#sqrtswap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.sqrtswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the square root SWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sqrtswap_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of square root SWAP gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.sqrtiswap">
<tt class="descname">sqrtiswap</tt><big>(</big><em>N=None, targets=[0, 1]</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#sqrtiswap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.sqrtiswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the square root iSWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sqrtiswap_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of square root iSWAP gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sqrtiswap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.00000000+0.j   0.00000000+0.j          0.00000000+0.j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.70710678+0.j          0.00000000-0.70710678j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.00000000-0.70710678j       0.70710678+0.j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.00000000+0.j          0.00000000+0.j          1.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.fredkin">
<tt class="descname">fredkin</tt><big>(</big><em>N=None, control=0, targets=[1, 2]</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#fredkin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.fredkin" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Fredkin gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fredkin_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of Fredkin gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fredkin</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.toffoli">
<tt class="descname">toffoli</tt><big>(</big><em>N=None, controls=[0, 1], target=2</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#toffoli"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.toffoli" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Toffoli gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>toff_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of Toffoli gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">toffoli</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.rotation">
<tt class="descname">rotation</tt><big>(</big><em>op</em>, <em>phi</em>, <em>N=None</em>, <em>target=0</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#rotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator op with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object for operator describing the rotation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.controlled_gate">
<tt class="descname">controlled_gate</tt><big>(</big><em>U</em>, <em>N=2</em>, <em>control=0</em>, <em>target=1</em>, <em>control_value=1</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#controlled_gate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.controlled_gate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an N-qubit controlled gate from a single-qubit gate U with the given
control and target qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>Arbitrary single-qubit gate.</p>
</div></blockquote>
<p><strong>N</strong> : integer</p>
<blockquote>
<div><p>The number of qubits in the target space.</p>
</div></blockquote>
<p><strong>control</strong> : integer</p>
<blockquote>
<div><p>The index of the first control qubit.</p>
</div></blockquote>
<p><strong>target</strong> : integer</p>
<blockquote>
<div><p>The index of the target qubit.</p>
</div></blockquote>
<p><strong>control_value</strong> : integer (1)</p>
<blockquote>
<div><p>The state of the control qubit that activates the gate U.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representing the controlled-U gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.globalphase">
<tt class="descname">globalphase</tt><big>(</big><em>theta</em>, <em>N=1</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#globalphase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.globalphase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the global phase shift gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : float</p>
<blockquote>
<div><p>Phase rotation angle.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>phase_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of global phase shift gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">phasegate</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.70710678+0.70710678j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j          0.70710678+0.70710678j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.hadamard_transform">
<tt class="descname">hadamard_transform</tt><big>(</big><em>N=1</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#hadamard_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.hadamard_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the N-qubit Hadamard gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>q</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of the N-qubit Hadamard gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_sequence_product">
<tt class="descname">gate_sequence_product</tt><big>(</big><em>U_list</em>, <em>left_to_right=True</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#gate_sequence_product"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_sequence_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the overall unitary matrix for a given list of unitary operations</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U_list</strong> : list</p>
<blockquote>
<div><p>List of gates implementing the quantum circuit.</p>
</div></blockquote>
<p><strong>left_to_right: Boolean</strong></p>
<blockquote>
<div><p>Check if multiplication is to be done from left to right.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">U_overall: qobj</p>
<blockquote class="last">
<div><p>Overall unitary matrix of a given quantum circuit.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_expand_1toN">
<tt class="descname">gate_expand_1toN</tt><big>(</big><em>U</em>, <em>N</em>, <em>target</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#gate_expand_1toN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_expand_1toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a one-qubit gate that act on a system with N
qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>The one-qubit gate</p>
</div></blockquote>
<p><strong>N</strong> : integer</p>
<blockquote>
<div><p>The number of qubits in the target space.</p>
</div></blockquote>
<p><strong>target</strong> : integer</p>
<blockquote>
<div><p>The index of the target qubit.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of N-qubit gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_expand_2toN">
<tt class="descname">gate_expand_2toN</tt><big>(</big><em>U</em>, <em>N</em>, <em>control=None</em>, <em>target=None</em>, <em>targets=None</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#gate_expand_2toN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_expand_2toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a two-qubit gate that act on a system with N
qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>The two-qubit gate</p>
</div></blockquote>
<p><strong>N</strong> : integer</p>
<blockquote>
<div><p>The number of qubits in the target space.</p>
</div></blockquote>
<p><strong>control</strong> : integer</p>
<blockquote>
<div><p>The index of the control qubit.</p>
</div></blockquote>
<p><strong>target</strong> : integer</p>
<blockquote>
<div><p>The index of the target qubit.</p>
</div></blockquote>
<p><strong>targets</strong> : list</p>
<blockquote>
<div><p>List of target qubits.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of N-qubit gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_expand_3toN">
<tt class="descname">gate_expand_3toN</tt><big>(</big><em>U, N, controls=[0, 1], target=2</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/gates.html#gate_expand_3toN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_expand_3toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a three-qubit gate that act on a system with N
qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>The three-qubit gate</p>
</div></blockquote>
<p><strong>N</strong> : integer</p>
<blockquote>
<div><p>The number of qubits in the target space.</p>
</div></blockquote>
<p><strong>controls</strong> : list</p>
<blockquote>
<div><p>The list of the control qubits.</p>
</div></blockquote>
<p><strong>target</strong> : integer</p>
<blockquote>
<div><p>The index of the target qubit.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of N-qubit gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.qip.qubits">
<span id="qubits"></span><h3>Qubits<a class="headerlink" href="#module-qutip.qip.qubits" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.qip.qubits.qubit_states">
<tt class="descname">qubit_states</tt><big>(</big><em>N=1, states=[0]</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/qubits.html#qubit_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.qubits.qubit_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to define initial state of the qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N: Integer</strong></p>
<blockquote>
<div><p>Number of qubits in the register.</p>
</div></blockquote>
<p><strong>states: List</strong></p>
<blockquote>
<div><p>Initial state of each qubit.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">qstates: Qobj</p>
<blockquote class="last">
<div><p>List of qubits.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.qip.algorithms.qft">
<span id="algorithms"></span><h3>Algorithms<a class="headerlink" href="#module-qutip.qip.algorithms.qft" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.qip.algorithms.qft.qft">
<tt class="descname">qft</tt><big>(</big><em>N=1</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/algorithms/qft.html#qft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.algorithms.qft.qft" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of qubits.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">QFT: qobj</p>
<blockquote class="last">
<div><p>Quantum Fourier transform operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.algorithms.qft.qft_steps">
<tt class="descname">qft_steps</tt><big>(</big><em>N=1</em>, <em>swapping=True</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/algorithms/qft.html#qft_steps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.algorithms.qft.qft_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits returning the individual
steps as unitary matrices operating from left to right.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N: int</strong></p>
<blockquote>
<div><p>Number of qubits.</p>
</div></blockquote>
<p><strong>swap: boolean</strong></p>
<blockquote>
<div><p>Flag indicating sequence of swap gates to be applied at the end or not.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">U_step_list: list of qobj</p>
<blockquote class="last">
<div><p>List of Hadamard and controlled rotation gates implementing QFT.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.algorithms.qft.qft_gate_sequence">
<tt class="descname">qft_gate_sequence</tt><big>(</big><em>N=1</em>, <em>swapping=True</em><big>)</big><a class="reference internal" href="../modules/qutip/qip/algorithms/qft.html#qft_gate_sequence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.algorithms.qft.qft_gate_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits returning the gate sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N: int</strong></p>
<blockquote>
<div><p>Number of qubits.</p>
</div></blockquote>
<p><strong>swap: boolean</strong></p>
<blockquote>
<div><p>Flag indicating sequence of swap gates to be applied at the end or not.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">qc: instance of QubitCircuit</p>
<blockquote class="last">
<div><p>Gate sequence of Hadamard and controlled rotation gates implementing
QFT.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-qutip.control.grape">
<span id="optimal-control"></span><span id="functions-metrics"></span><h2>Optimal control<a class="headerlink" href="#module-qutip.control.grape" title="Permalink to this headline">¶</a></h2>
<p>This module contains functions that implement the GRAPE algorithm for
calculating pulse sequences for quantum systems.</p>
<dl class="function">
<dt id="qutip.control.grape.plot_grape_control_fields">
<tt class="descname">plot_grape_control_fields</tt><big>(</big><em>times</em>, <em>u</em>, <em>labels</em>, <em>uniform_axes=False</em><big>)</big><a class="reference internal" href="../modules/qutip/control/grape.html#plot_grape_control_fields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.grape.plot_grape_control_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a series of plots showing the GRAPE control fields given in the
given control pulse matrix u.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : array</p>
<blockquote>
<div><p>Time coordinate array.</p>
</div></blockquote>
<p><strong>u</strong> : array</p>
<blockquote>
<div><p>Control pulse matrix.</p>
</div></blockquote>
<p><strong>labels</strong> : list</p>
<blockquote>
<div><p>List of labels for each control pulse sequence in the control pulse
matrix.</p>
</div></blockquote>
<p><strong>uniform_axes</strong> : bool</p>
<blockquote class="last">
<div><p>Whether or not to plot all pulse sequences using the same y-axis scale.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.control.grape.grape_unitary">
<tt class="descname">grape_unitary</tt><big>(</big><em>U</em>, <em>H0</em>, <em>H_ops</em>, <em>R</em>, <em>times</em>, <em>eps=None</em>, <em>u_start=None</em>, <em>u_limits=None</em>, <em>interp_kind='linear'</em>, <em>use_interp=False</em>, <em>alpha=None</em>, <em>beta=None</em>, <em>phase_sensitive=True</em>, <em>progress_bar=&lt;qutip.ui.progressbar.BaseProgressBar object at 0x107b6fd90&gt;</em><big>)</big><a class="reference internal" href="../modules/qutip/control/grape.html#grape_unitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.grape.grape_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate control pulses for the Hamiltonian operators in H_ops so that the
unitary U is realized.</p>
<p>Experimental: Work in progress.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>Target unitary evolution operator.</p>
</div></blockquote>
<p><strong>H0</strong> : Qobj</p>
<blockquote>
<div><p>Static Hamiltonian (that cannot be tuned by the control fields).</p>
</div></blockquote>
<p><strong>H_ops: list of Qobj</strong></p>
<blockquote>
<div><p>A list of operators that can be tuned in the Hamiltonian via the
control fields.</p>
</div></blockquote>
<p><strong>R</strong> : int</p>
<blockquote>
<div><p>Number of GRAPE iterations.</p>
</div></blockquote>
<p><strong>time</strong> : array / list</p>
<blockquote>
<div><p>Array of time coordinates for control pulse evalutation.</p>
</div></blockquote>
<p><strong>u_start</strong> : array</p>
<blockquote>
<div><p>Optional array with initial control pulse values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Instance of GRAPEResult, which contains the control pulses calculated</p>
<blockquote class="last">
<div><p>with GRAPE, a time-dependent Hamiltonian that is defined by the
control pulses, as well as the resulting propagator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.control.grape.grape_unitary_adaptive">
<tt class="descname">grape_unitary_adaptive</tt><big>(</big><em>U</em>, <em>H0</em>, <em>H_ops</em>, <em>R</em>, <em>times</em>, <em>eps=None</em>, <em>u_start=None</em>, <em>u_limits=None</em>, <em>interp_kind='linear'</em>, <em>use_interp=False</em>, <em>alpha=None</em>, <em>beta=None</em>, <em>phase_sensitive=False</em>, <em>overlap_terminate=1.0</em>, <em>progress_bar=&lt;qutip.ui.progressbar.BaseProgressBar object at 0x107be58d0&gt;</em><big>)</big><a class="reference internal" href="../modules/qutip/control/grape.html#grape_unitary_adaptive"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.grape.grape_unitary_adaptive" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate control pulses for the Hamiltonian operators in H_ops so that
the unitary U is realized.</p>
<p>Experimental: Work in progress.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>Target unitary evolution operator.</p>
</div></blockquote>
<p><strong>H0</strong> : Qobj</p>
<blockquote>
<div><p>Static Hamiltonian (that cannot be tuned by the control fields).</p>
</div></blockquote>
<p><strong>H_ops: list of Qobj</strong></p>
<blockquote>
<div><p>A list of operators that can be tuned in the Hamiltonian via the
control fields.</p>
</div></blockquote>
<p><strong>R</strong> : int</p>
<blockquote>
<div><p>Number of GRAPE iterations.</p>
</div></blockquote>
<p><strong>time</strong> : array / list</p>
<blockquote>
<div><p>Array of time coordinates for control pulse evalutation.</p>
</div></blockquote>
<p><strong>u_start</strong> : array</p>
<blockquote>
<div><p>Optional array with initial control pulse values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Instance of GRAPEResult, which contains the control pulses calculated</p>
<blockquote class="last">
<div><p>with GRAPE, a time-dependent Hamiltonian that is defined by the
control pulses, as well as the resulting propagator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-qutip.control.pulseoptim"></span><p>Wrapper functions that will manage the creation of the objects,
build the configuration, and execute the algorithm required to optimise
a set of ctrl pulses for a given (quantum) system.
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.
The functions minimise this fidelity error wrt the piecewise control
amplitudes in the timeslots</p>
<dl class="function">
<dt id="qutip.control.pulseoptim.optimize_pulse">
<tt class="descname">optimize_pulse</tt><big>(</big><em>drift</em>, <em>ctrls</em>, <em>initial</em>, <em>target</em>, <em>num_tslots=None</em>, <em>evo_time=None</em>, <em>tau=None</em>, <em>amp_lbound=-inf</em>, <em>amp_ubound=inf</em>, <em>fid_err_targ=1e-10</em>, <em>min_grad=1e-10</em>, <em>max_iter=500</em>, <em>max_wall_time=180</em>, <em>optim_alg='LBFGSB'</em>, <em>max_metric_corr=10</em>, <em>accuracy_factor=10000000.0</em>, <em>dyn_type='GEN_MAT'</em>, <em>prop_type='DEF'</em>, <em>fid_type='DEF'</em>, <em>phase_option=None</em>, <em>fid_err_scale_factor=None</em>, <em>amp_update_mode='ALL'</em>, <em>init_pulse_type='RND'</em>, <em>pulse_scaling=1.0</em>, <em>pulse_offset=0.0</em>, <em>log_level=0</em>, <em>out_file_ext=None</em>, <em>gen_stats=False</em><big>)</big><a class="reference internal" href="../modules/qutip/control/pulseoptim.html#optimize_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.optimize_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error.
The dynamics of the system in any given timeslot are governed
by the combined dynamics generator,
i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]
The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes
Starting from an intital (typically random) pulse,
a multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>drift</strong> : Qobj</p>
<blockquote>
<div><p>the underlying dynamics generator of the system</p>
</div></blockquote>
<p><strong>ctrls</strong> : List of Qobj</p>
<blockquote>
<div><p>a list of control dynamics generators. These are scaled by
the amplitudes to alter the overall dynamics</p>
</div></blockquote>
<p><strong>initial</strong> : Qobj</p>
<blockquote>
<div><p>starting point for the evolution.
Typically the identity matrix</p>
</div></blockquote>
<p><strong>target</strong> : Qobj</p>
<blockquote>
<div><p>target transformation, e.g. gate or state, for the time evolution</p>
</div></blockquote>
<p><strong>num_tslots</strong> : integer or None</p>
<blockquote>
<div><p>number of timeslots.
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>evo_time</strong> : float or None</p>
<blockquote>
<div><p>total time for the evolution
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>tau</strong> : array[num_tslots] of floats or None</p>
<blockquote>
<div><p>durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</div></blockquote>
<p><strong>amp_lbound</strong> : float or list of floats</p>
<blockquote>
<div><p>lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>amp_ubound</strong> : float or list of floats</p>
<blockquote>
<div><p>upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>fid_err_targ</strong> : float</p>
<blockquote>
<div><p>Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</div></blockquote>
<p><strong>mim_grad</strong> : float</p>
<blockquote>
<div><p>Minimum gradient. When the sum of the squares of the
gradients wrt to the control amplitudes falls below this
value, the optimisation terminates, assuming local minima</p>
</div></blockquote>
<p><strong>max_iter</strong> : integer</p>
<blockquote>
<div><p>Maximum number of iterations of the optimisation algorithm</p>
</div></blockquote>
<p><strong>max_wall_time</strong> : float</p>
<blockquote>
<div><p>Maximum allowed elapsed time for the  optimisation algorithm</p>
</div></blockquote>
<p><strong>optim_alg</strong> : string</p>
<blockquote>
<div><p>Multi-variable optimisation algorithm
options are BFGS, LBFGSB
(see Optimizer classes for details)</p>
</div></blockquote>
<p><strong>max_metric_corr</strong> : integer</p>
<blockquote>
<div><p>The maximum number of variable metric corrections used to define
the limited memory matrix. That is the number of previous
gradient values that are used to approximate the Hessian
see the scipy.optimize.fmin_l_bfgs_b documentation for description
of m argument
(used only in L-BFGS-B)</p>
</div></blockquote>
<p><strong>accuracy_factor</strong> : float</p>
<blockquote>
<div><p>Determines the accuracy of the result.
Typical values for accuracy_factor are: 1e12 for low accuracy;
1e7 for moderate accuracy; 10.0 for extremely high accuracy
scipy.optimize.fmin_l_bfgs_b factr argument.
(used only in L-BFGS-B)</p>
</div></blockquote>
<p><strong>dyn_type</strong> : string</p>
<blockquote>
<div><p>Dynamics type, i.e. the type of matrix used to describe
the dynamics. Options are UNIT, GEN_MAT, SYMPL
(see Dynamics classes for details)</p>
</div></blockquote>
<p><strong>prop_type</strong> : string</p>
<blockquote>
<div><p>Propagator type i.e. the method used to calculate the
propagtors and propagtor gradient for each timeslot
options are DEF, APPROX, DIAG, FRECHET, AUG_MAT
DEF will use the default for the specific dyn_type
(see PropagatorComputer classes for details)</p>
</div></blockquote>
<p><strong>fid_type</strong> : string</p>
<blockquote>
<div><p>Fidelity error (and fidelity error gradient) computation method
Options are DEF, UNIT, TRACEDIFF, TD_APPROX
DEF will use the default for the specific dyn_type
(See FideliyComputer classes for details)</p>
</div></blockquote>
<p><strong>phase_option</strong> : string</p>
<blockquote>
<div><p>determines how global phase is treated in fidelity
calculations (fid_type=&#8217;UNIT&#8217; only). Options:</p>
<blockquote>
<div><p>PSU - global phase ignored
SU - global phase included</p>
</div></blockquote>
</div></blockquote>
<p><strong>fid_err_scale_factor</strong> : float</p>
<blockquote>
<div><p>(used in TRACEDIFF FidelityComputer and subclasses only)
The fidelity error calculated is of some arbitary scale. This
factor can be used to scale the fidelity error such that it may
represent some physical measure
If None is given then it is caculated as 1/2N, where N
is the dimension of the drift.</p>
</div></blockquote>
<p><strong>amp_update_mode</strong> : string</p>
<blockquote>
<div><p>determines whether propagators are calculated
Options: DEF, ALL, DYNAMIC (needs work)
DEF will use the default for the specific dyn_type
(See TimeslotComputer classes for details)</p>
</div></blockquote>
<p><strong>init_pulse_type</strong> : string</p>
<blockquote>
<div><p>type / shape of pulse(s) used to initialise the
the control amplitudes. Options include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW</p>
</div></blockquote>
<p>(see PulseGen classes for details)</p>
</div></blockquote>
<p><strong>pulse_scaling</strong> : float</p>
<blockquote>
<div><p>Linear scale factor for generated pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</div></blockquote>
<p><strong>pulse_offset</strong> : float</p>
<blockquote>
<div><p>Line offset for the pulse. That is this value will be added
to any initial pulses generated.</p>
</div></blockquote>
<p><strong>log_level</strong> : integer</p>
<blockquote>
<div><p>level of messaging output from the logger.
Options are attributes of qutip.logging,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively &#8216;quiet&#8217; execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</div></blockquote>
<p><strong>out_file_ext</strong> : string or None</p>
<blockquote>
<div><p>files containing the initial and final control pulse
amplitudes are saved to the current directory.
The default name will be postfixed with this extension
Setting this to None will suppress the output of files</p>
</div></blockquote>
<p><strong>gen_stats</strong> : boolean</p>
<blockquote>
<div><p>if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Returns instance of OptimResult, which has attributes giving the</p>
<blockquote class="last">
<div><p>reason for termination, final fidelity error, final evolution
final amplitudes, statistics etc</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.control.pulseoptim.optimize_pulse_unitary">
<tt class="descname">optimize_pulse_unitary</tt><big>(</big><em>H_d</em>, <em>H_c</em>, <em>U_0</em>, <em>U_targ</em>, <em>num_tslots=None</em>, <em>evo_time=None</em>, <em>tau=None</em>, <em>amp_lbound=-inf</em>, <em>amp_ubound=inf</em>, <em>fid_err_targ=1e-10</em>, <em>min_grad=1e-10</em>, <em>max_iter=500</em>, <em>max_wall_time=180</em>, <em>optim_alg='LBFGSB'</em>, <em>max_metric_corr=10</em>, <em>accuracy_factor=10000000.0</em>, <em>phase_option='PSU'</em>, <em>amp_update_mode='ALL'</em>, <em>init_pulse_type='RND'</em>, <em>pulse_scaling=1.0</em>, <em>pulse_offset=0.0</em>, <em>log_level=0</em>, <em>out_file_ext='.txt'</em>, <em>gen_stats=False</em><big>)</big><a class="reference internal" href="../modules/qutip/control/pulseoptim.html#optimize_pulse_unitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.optimize_pulse_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error, assuming that
the dynamics of the system are generated by unitary operators.
This function is simply a wrapper for optimize_pulse, where the
appropriate options for unitary dynamics are chosen and the parameter
names are in the format familiar to unitary dynamics
The dynamics of the system  in any given timeslot are governed
by the combined Hamiltonian,
i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]
The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes
Starting from an intital (typically random) pulse,
a multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error
The maximum fidelity for a unitary system is 1, i.e. when the
time evolution resulting from the pulse is equivalent to the target.
And therefore the fidelity error is 1 - fidelity</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H_d</strong> : Qobj</p>
<blockquote>
<div><p>Drift (aka system) the underlying Hamiltonian of the system</p>
</div></blockquote>
<p><strong>H_c</strong> : Qobj</p>
<blockquote>
<div><p>a list of control Hamiltonians. These are scaled by
the amplitudes to alter the overall dynamics</p>
</div></blockquote>
<p><strong>U_0</strong> : Qobj</p>
<blockquote>
<div><p>starting point for the evolution.
Typically the identity matrix</p>
</div></blockquote>
<p><strong>U_targ</strong> : Qobj</p>
<blockquote>
<div><p>target transformation, e.g. gate or state, for the time evolution</p>
</div></blockquote>
<p><strong>num_tslots</strong> : integer or None</p>
<blockquote>
<div><p>number of timeslots.
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>evo_time</strong> : float or None</p>
<blockquote>
<div><p>total time for the evolution
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>tau</strong> : array[num_tslots] of floats or None</p>
<blockquote>
<div><p>durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</div></blockquote>
<p><strong>amp_lbound</strong> : float or list of floats</p>
<blockquote>
<div><p>lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>amp_ubound</strong> : float or list of floats</p>
<blockquote>
<div><p>upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>fid_err_targ</strong> : float</p>
<blockquote>
<div><p>Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</div></blockquote>
<p><strong>mim_grad</strong> : float</p>
<blockquote>
<div><p>Minimum gradient. When the sum of the squares of the
gradients wrt to the control amplitudes falls below this
value, the optimisation terminates, assuming local minima</p>
</div></blockquote>
<p><strong>max_iter</strong> : integer</p>
<blockquote>
<div><p>Maximum number of iterations of the optimisation algorithm</p>
</div></blockquote>
<p><strong>max_wall_time</strong> : float</p>
<blockquote>
<div><p>Maximum allowed elapsed time for the  optimisation algorithm</p>
</div></blockquote>
<p><strong>optim_alg</strong> : string</p>
<blockquote>
<div><p>Multi-variable optimisation algorithm
options are BFGS, LBFGSB
(see Optimizer classes for details)</p>
</div></blockquote>
<p><strong>max_metric_corr</strong> : integer</p>
<blockquote>
<div><p>The maximum number of variable metric corrections used to define
the limited memory matrix. That is the number of previous
gradient values that are used to approximate the Hessian
see the scipy.optimize.fmin_l_bfgs_b documentation for description
of m argument
(used only in L-BFGS-B)</p>
</div></blockquote>
<p><strong>accuracy_factor</strong> : float</p>
<blockquote>
<div><p>Determines the accuracy of the result.
Typical values for accuracy_factor are: 1e12 for low accuracy;
1e7 for moderate accuracy; 10.0 for extremely high accuracy
scipy.optimize.fmin_l_bfgs_b factr argument.
(used only in L-BFGS-B)</p>
</div></blockquote>
<p><strong>phase_option</strong> : string</p>
<blockquote>
<div><p>determines how global phase is treated in fidelity
calculations (fid_type=&#8217;UNIT&#8217; only). Options:</p>
<blockquote>
<div><p>PSU - global phase ignored
SU - global phase included</p>
</div></blockquote>
</div></blockquote>
<p><strong>amp_update_mode</strong> : string</p>
<blockquote>
<div><p>determines whether propagators are calculated
Options: DEF, ALL, DYNAMIC (needs work)
DEF will use the default for the specific dyn_type
(See TimeslotComputer classes for details)</p>
</div></blockquote>
<p><strong>init_pulse_type</strong> : string</p>
<blockquote>
<div><p>type / shape of pulse(s) used to initialise the
the control amplitudes. Options include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW</p>
</div></blockquote>
<p>(see PulseGen classes for details)</p>
</div></blockquote>
<p><strong>pulse_scaling</strong> : float</p>
<blockquote>
<div><p>Linear scale factor for generated pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</div></blockquote>
<p><strong>pulse_offset</strong> : float</p>
<blockquote>
<div><p>Line offset for the pulse. That is this value will be added
to any initial pulses generated.</p>
</div></blockquote>
<p><strong>log_level</strong> : integer</p>
<blockquote>
<div><p>level of messaging output from the logger.
Options are attributes of qutip.logging,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively &#8216;quiet&#8217; execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</div></blockquote>
<p><strong>out_file_ext</strong> : string or None</p>
<blockquote>
<div><p>files containing the initial and final control pulse
amplitudes are saved to the current directory.
The default name will be postfixed with this extension
Setting this to None will suppress the output of files</p>
</div></blockquote>
<p><strong>gen_stats</strong> : boolean</p>
<blockquote>
<div><p>if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Returns instance of OptimResult, which has attributes giving the</p>
<blockquote class="last">
<div><p>reason for termination, final fidelity error, final evolution
final amplitudes, statistics etc</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.control.pulseoptim.create_pulse_optimizer">
<tt class="descname">create_pulse_optimizer</tt><big>(</big><em>drift</em>, <em>ctrls</em>, <em>initial</em>, <em>target</em>, <em>num_tslots=None</em>, <em>evo_time=None</em>, <em>tau=None</em>, <em>amp_lbound=-inf</em>, <em>amp_ubound=inf</em>, <em>fid_err_targ=1e-10</em>, <em>min_grad=1e-10</em>, <em>max_iter=500</em>, <em>max_wall_time=180</em>, <em>optim_alg='LBFGSB'</em>, <em>max_metric_corr=10</em>, <em>accuracy_factor=10000000.0</em>, <em>dyn_type='GEN_MAT'</em>, <em>prop_type='DEF'</em>, <em>fid_type='DEF'</em>, <em>phase_option=None</em>, <em>fid_err_scale_factor=None</em>, <em>amp_update_mode='ALL'</em>, <em>init_pulse_type='RND'</em>, <em>pulse_scaling=1.0</em>, <em>pulse_offset=0.0</em>, <em>log_level=0</em>, <em>gen_stats=False</em><big>)</big><a class="reference internal" href="../modules/qutip/control/pulseoptim.html#create_pulse_optimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.create_pulse_optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the objects of the appropriate subclasses
required for the pulse optmisation based on the parameters given
Note this method may be preferable to calling optimize_pulse
if more detailed configuration is required before running the
optmisation algorthim, or the algorithm will be run many times,
for instances when trying to finding global the optimum or
minimum time optimisation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>drift</strong> : Qobj</p>
<blockquote>
<div><p>the underlying dynamics generator of the system</p>
</div></blockquote>
<p><strong>ctrls</strong> : List of Qobj</p>
<blockquote>
<div><p>a list of control dynamics generators. These are scaled by
the amplitudes to alter the overall dynamics</p>
</div></blockquote>
<p><strong>initial</strong> : Qobj</p>
<blockquote>
<div><p>starting point for the evolution.
Typically the identity matrix</p>
</div></blockquote>
<p><strong>target</strong> : Qobj</p>
<blockquote>
<div><p>target transformation, e.g. gate or state, for the time evolution</p>
</div></blockquote>
<p><strong>num_tslots</strong> : integer or None</p>
<blockquote>
<div><p>number of timeslots.
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>evo_time</strong> : float or None</p>
<blockquote>
<div><p>total time for the evolution
None implies that timeslots will be given in the tau array</p>
</div></blockquote>
<p><strong>tau</strong> : array[num_tslots] of floats or None</p>
<blockquote>
<div><p>durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</div></blockquote>
<p><strong>amp_lbound</strong> : float or list of floats</p>
<blockquote>
<div><p>lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>amp_ubound</strong> : float or list of floats</p>
<blockquote>
<div><p>upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</div></blockquote>
<p><strong>fid_err_targ</strong> : float</p>
<blockquote>
<div><p>Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</div></blockquote>
<p><strong>mim_grad</strong> : float</p>
<blockquote>
<div><p>Minimum gradient. When the sum of the squares of the
gradients wrt to the control amplitudes falls below this
value, the optimisation terminates, assuming local minima</p>
</div></blockquote>
<p><strong>max_iter</strong> : integer</p>
<blockquote>
<div><p>Maximum number of iterations of the optimisation algorithm</p>
</div></blockquote>
<p><strong>max_wall_time</strong> : float</p>
<blockquote>
<div><p>Maximum allowed elapsed time for the  optimisation algorithm</p>
</div></blockquote>
<p><strong>optim_alg</strong> : string</p>
<blockquote>
<div><p>Multi-variable optimisation algorithm
options are BFGS, LBFGSB
(see Optimizer classes for details)</p>
</div></blockquote>
<p><strong>max_metric_corr</strong> : integer</p>
<blockquote>
<div><p>The maximum number of variable metric corrections used to define
the limited memory matrix. That is the number of previous
gradient values that are used to approximate the Hessian
see the scipy.optimize.fmin_l_bfgs_b documentation for description
of m argument
(used only in L-BFGS-B)</p>
</div></blockquote>
<p><strong>accuracy_factor</strong> : float</p>
<blockquote>
<div><p>Determines the accuracy of the result.
Typical values for accuracy_factor are: 1e12 for low accuracy;
1e7 for moderate accuracy; 10.0 for extremely high accuracy
scipy.optimize.fmin_l_bfgs_b factr argument.
(used only in L-BFGS-B)</p>
</div></blockquote>
<p><strong>dyn_type</strong> : string</p>
<blockquote>
<div><p>Dynamics type, i.e. the type of matrix used to describe
the dynamics. Options are UNIT, GEN_MAT, SYMPL
(see Dynamics classes for details)</p>
</div></blockquote>
<p><strong>prop_type</strong> : string</p>
<blockquote>
<div><p>Propagator type i.e. the method used to calculate the
propagtors and propagtor gradient for each timeslot
options are DEF, APPROX, DIAG, FRECHET, AUG_MAT
DEF will use the default for the specific dyn_type
(see PropagatorComputer classes for details)</p>
</div></blockquote>
<p><strong>fid_type</strong> : string</p>
<blockquote>
<div><p>Fidelity error (and fidelity error gradient) computation method
Options are DEF, UNIT, TRACEDIFF, TD_APPROX
DEF will use the default for the specific dyn_type
(See FideliyComputer classes for details)</p>
</div></blockquote>
<p><strong>phase_option</strong> : string</p>
<blockquote>
<div><p>determines how global phase is treated in fidelity
calculations (fid_type=&#8217;UNIT&#8217; only). Options:</p>
<blockquote>
<div><p>PSU - global phase ignored
SU - global phase included</p>
</div></blockquote>
</div></blockquote>
<p><strong>fid_err_scale_factor</strong> : float</p>
<blockquote>
<div><p>(used in TRACEDIFF FidelityComputer and subclasses only)
The fidelity error calculated is of some arbitary scale. This
factor can be used to scale the fidelity error such that it may
represent some physical measure
If None is given then it is caculated as 1/2N, where N
is the dimension of the drift.</p>
</div></blockquote>
<p><strong>amp_update_mode</strong> : string</p>
<blockquote>
<div><p>determines whether propagators are calculated
Options: DEF, ALL, DYNAMIC (needs work)
DEF will use the default for the specific dyn_type
(See TimeslotComputer classes for details)</p>
</div></blockquote>
<p><strong>init_pulse_type</strong> : string</p>
<blockquote>
<div><p>type / shape of pulse(s) used to initialise the
the control amplitudes. Options include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW</p>
</div></blockquote>
<p>(see PulseGen classes for details)</p>
</div></blockquote>
<p><strong>pulse_scaling</strong> : float</p>
<blockquote>
<div><p>Linear scale factor for generated pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</div></blockquote>
<p><strong>pulse_offset</strong> : float</p>
<blockquote>
<div><p>Line offset for the pulse. That is this value will be added
to any initial pulses generated.</p>
</div></blockquote>
<p><strong>log_level</strong> : integer</p>
<blockquote>
<div><p>level of messaging output from the logger.
Options are attributes of qutip.logging,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively &#8216;quiet&#8217; execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN
Note value should be set using set_log_level</p>
</div></blockquote>
<p><strong>gen_stats</strong> : boolean</p>
<blockquote>
<div><p>if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Instance of an Optimizer, through which the</p>
<blockquote class="last">
<div><p>Config, Dynamics, PulseGen, and TerminationConditions objects
can be accessed as attributes.
The PropagatorComputer, FidelityComputer and TimeslotComputer objects
can be accessed as attributes of the Dynamics object, e.g.</p>
<blockquote>
<div><p>optimizer.dynamics.fid_computer</p>
</div></blockquote>
<p>The optimisation can be run through the optimizer.run_optimization</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-qutip.control.pulsegen"></span><p>Pulse generator - Generate pulses for the timeslots
Each class defines a gen_pulse function that produces a float array of
size num_tslots. Each class produces a differ type of pulse.
See the class and gen_pulse function descriptions for details</p>
<dl class="function">
<dt id="qutip.control.pulsegen.create_pulse_gen">
<tt class="descname">create_pulse_gen</tt><big>(</big><em>pulse_type='RND'</em>, <em>dyn=None</em><big>)</big><a class="reference internal" href="../modules/qutip/control/pulsegen.html#create_pulse_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.create_pulse_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a pulse generator object matching the given type.
The pulse generators each produce a different type of pulse,
see the gen_pulse function description for details.
These are the random pulse options:</p>
<blockquote>
<div>RND - Independent random value in each timeslot
RNDFOURIER - Fourier series with random coefficients
RNDWAVES - Summation of random waves
RNDWALK1 - Random change in amplitude each timeslot
RNDWALK2 - Random change in amp gradient each timeslot</div></blockquote>
<dl class="docutils">
<dt>These are the other non-periodic options:</dt>
<dd>LIN - Linear, i.e. contant gradient over the time
ZERO - special case of the LIN pulse, where the gradient is 0</dd>
<dt>These are the periodic options</dt>
<dd>SINE - Sine wave
SQUARE - Square wave
SAW - Saw tooth wave
TRIANGLE - Triangular wave</dd>
</dl>
<p>If a Dynamics object is passed in then this is used in instantiate
the PulseGen, meaning that some timeslot and amplitude properties
are copied over.</p>
</dd></dl>

<span class="target" id="module-qutip.control.pulsegen"></span><p>Pulse generator - Generate pulses for the timeslots
Each class defines a gen_pulse function that produces a float array of
size num_tslots. Each class produces a differ type of pulse.
See the class and gen_pulse function descriptions for details</p>
</div>
<div class="section" id="utilitiy-functions">
<h2>Utilitiy Functions<a class="headerlink" href="#utilitiy-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.graph">
<span id="graph-theory-routines"></span><h3>Graph Theory Routines<a class="headerlink" href="#module-qutip.graph" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection of graph theory routines used mainly
to reorder matrices for iterative steady state solvers.</p>
<dl class="function">
<dt id="qutip.graph.breadth_first_search">
<tt class="descname">breadth_first_search</tt><big>(</big><em>A</em>, <em>start</em><big>)</big><a class="reference internal" href="../modules/qutip/graph.html#breadth_first_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.breadth_first_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting
from a given node (row).  Takes Qobjs and CSR or CSC matrices as inputs.</p>
<p>This function requires a matrix with symmetric structure.
Use A+trans(A) if original matrix is not symmetric or not sure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : csc_matrix, csr_matrix</p>
<blockquote>
<div><p>Input graph in CSC or CSR matrix format</p>
</div></blockquote>
<p><strong>start</strong> : int</p>
<blockquote>
<div><p>Staring node for BFS traversal.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>order</strong> : array</p>
<blockquote>
<div><p>Order in which nodes are traversed from starting node.</p>
</div></blockquote>
<p><strong>levels</strong> : array</p>
<blockquote class="last">
<div><p>Level of the nodes in the order that they are traversed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.graph_degree">
<tt class="descname">graph_degree</tt><big>(</big><em>A</em><big>)</big><a class="reference internal" href="../modules/qutip/graph.html#graph_degree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.graph_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the degree for the nodes (rows) of a symmetric
graph in sparse CSR or CSC format, or a qobj.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj, csr_matrix, csc_matrix</p>
<blockquote>
<div><p>Input quantum object or csr_matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>degree</strong> : array</p>
<blockquote class="last">
<div><p>Array of integers giving the degree for each node (row).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.reverse_cuthill_mckee">
<tt class="descname">reverse_cuthill_mckee</tt><big>(</big><em>A</em>, <em>sym=False</em><big>)</big><a class="reference internal" href="../modules/qutip/graph.html#reverse_cuthill_mckee"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.reverse_cuthill_mckee" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the permutation array that orders a sparse CSR or CSC matrix
in Reverse-Cuthill McKee ordering. Since the input matrix must be
symmetric, this routine works on the matrix A+Trans(A) if the sym flag is
set to False (Default).</p>
<p>It is assumed by default (<em>sym=False</em>) that the input matrix is not
symmetric. This is because it is faster to do A+Trans(A) than it is to
check for symmetry for a generic matrix. If you are guaranteed that the
matrix is symmetric in structure (values of matrix element do not matter)
then set <em>sym=True</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : csc_matrix, csr_matrix</p>
<blockquote>
<div><p>Input sparse CSC or CSR sparse matrix format.</p>
</div></blockquote>
<p><strong>sym</strong> : bool {False, True}</p>
<blockquote>
<div><p>Flag to set whether input matrix is symmetric.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>perm</strong> : array</p>
<blockquote class="last">
<div><p>Array of permuted row and column indices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This routine is used primarily for internal reordering of Lindblad
superoperators for use in iterative solver routines.</p>
<p class="rubric">References</p>
<p>E. Cuthill and J. McKee, &#8220;Reducing the Bandwidth of Sparse Symmetric
Matrices&#8221;, ACM &#8216;69 Proceedings of the 1969 24th national conference,
(1969).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.maximum_bipartite_matching">
<tt class="descname">maximum_bipartite_matching</tt><big>(</big><em>A</em>, <em>perm_type='row'</em><big>)</big><a class="reference internal" href="../modules/qutip/graph.html#maximum_bipartite_matching"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.maximum_bipartite_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of row or column permutations that removes nonzero
elements from the diagonal of a nonsingular square CSC sparse matrix. Such
a permutation is always possible provided that the matrix is nonsingular.
This function looks at the structure of the matrix only.</p>
<p>The input matrix will be converted to CSC matrix format if
necessary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : sparse matrix</p>
<blockquote>
<div><p>Input matrix</p>
</div></blockquote>
<p><strong>perm_type</strong> : str {&#8216;row&#8217;, &#8216;column&#8217;}</p>
<blockquote>
<div><p>Type of permutation to generate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>perm</strong> : array</p>
<blockquote class="last">
<div><p>Array of row or column permutations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function relies on a maximum cardinality bipartite matching algorithm
based on a breadth-first search (BFS) of the underlying graph[R3]_.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[R3]</a></td><td><ol class="first last upperroman simple">
<li><ol class="first upperalpha" start="19">
<li>Duff, K. Kaya, and B. Ucar, &#8220;Design, Implementation, and</li>
</ol>
</li>
</ol>
</td></tr>
</tbody>
</table>
<p>Analysis of Maximum Transversal Algorithms&#8221;, ACM Trans. Math. Softw.
38, no. 2, (2011).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.weighted_bipartite_matching">
<tt class="descname">weighted_bipartite_matching</tt><big>(</big><em>A</em>, <em>perm_type='row'</em><big>)</big><a class="reference internal" href="../modules/qutip/graph.html#weighted_bipartite_matching"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.weighted_bipartite_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of row permutations that attempts to maximize
the product of the ABS values of the diagonal elements in
a nonsingular square CSC sparse matrix. Such a permutation is
always possible provided that the matrix is nonsingular.</p>
<p>This function looks at both the structure and ABS values of the
underlying matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : csc_matrix</p>
<blockquote>
<div><p>Input matrix</p>
</div></blockquote>
<p><strong>perm_type</strong> : str {&#8216;row&#8217;, &#8216;column&#8217;}</p>
<blockquote>
<div><p>Type of permutation to generate.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>perm</strong> : array</p>
<blockquote class="last">
<div><p>Array of row or column permutations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function uses a weighted maximum cardinality bipartite matching
algorithm based on breadth-first search (BFS).  The columns are weighted
according to the element of max ABS value in the associated rows and
are traversed in descending order by weight.  When performing the BFS
traversal, the row associated to a given column is the one with maximum
weight. Unlike other techniques[R4]_, this algorithm does not guarantee the
product of the diagonal is maximized.  However, this limitation is offset
by the substantially faster runtime of this method.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[R4]</a></td><td><ol class="first last upperroman simple">
<li><ol class="first upperalpha" start="19">
<li>Duff and J. Koster, &#8220;The design and use of algorithms for</li>
</ol>
</li>
</ol>
</td></tr>
</tbody>
</table>
<p>permuting large entries to the diagonal of sparse matrices&#8221;, SIAM J.
Matrix Anal. and Applics. 20, no. 4, 889 (1997).</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.utilities">
<span id="utility-functions"></span><span id="functions-utilities"></span><h3>Utility Functions<a class="headerlink" href="#module-qutip.utilities" title="Permalink to this headline">¶</a></h3>
<p>This module contains utility functions that are commonly needed in other
qutip modules.</p>
<dl class="function">
<dt id="qutip.utilities.n_thermal">
<tt class="descname">n_thermal</tt><big>(</big><em>w</em>, <em>w_th</em><big>)</big><a class="reference internal" href="../modules/qutip/utilities.html#n_thermal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.n_thermal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of photons in thermal equilibrium for an harmonic
oscillator mode with frequency &#8216;w&#8217;, at the temperature described by
&#8216;w_th&#8217; where <span class="math">\(\omega_{\rm th} = k_BT/\hbar\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>w</strong> : <em>float</em> or <em>array</em></p>
<blockquote>
<div><p>Frequency of the oscillator.</p>
</div></blockquote>
<p><strong>w_th</strong> : <em>float</em></p>
<blockquote>
<div><p>The temperature in units of frequency (or the same units as <cite>w</cite>).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>n_avg</strong> : <em>float</em> or <em>array</em></p>
<blockquote class="last">
<div><p>Return the number of average photons in thermal equilibrium for a
an oscillator with the given frequency and temperature.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.utilities.linspace_with">
<tt class="descname">linspace_with</tt><big>(</big><em>start</em>, <em>stop</em>, <em>num=50</em>, <em>elems=[]</em><big>)</big><a class="reference internal" href="../modules/qutip/utilities.html#linspace_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.linspace_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of numbers sampled over specified interval
with additional elements added.</p>
<p>Returns <cite>num</cite> spaced array with elements from <cite>elems</cite> inserted
if not already included in set.</p>
<p>Returned sample array is not evenly spaced if addtional elements
are added.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>start</strong> : int</p>
<blockquote>
<div><p>The starting value of the sequence.</p>
</div></blockquote>
<p><strong>stop</strong> : int</p>
<blockquote>
<div><p>The stoping values of the sequence.</p>
</div></blockquote>
<p><strong>num</strong> : int, optional</p>
<blockquote>
<div><p>Number of samples to generate.</p>
</div></blockquote>
<p><strong>elems</strong> : list/ndarray, optional</p>
<blockquote>
<div><p>Requested elements to include in array</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>samples</strong> : ndadrray</p>
<blockquote class="last">
<div><p>Original equally spaced sample array with additional
elements added.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.utilities.clebsch">
<tt class="descname">clebsch</tt><big>(</big><em>j1</em>, <em>j2</em>, <em>j3</em>, <em>m1</em>, <em>m2</em>, <em>m3</em><big>)</big><a class="reference internal" href="../modules/qutip/utilities.html#clebsch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.clebsch" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Clebsch-Gordon coefficient
for coupling (j1,m1) and (j2,m2) to give (j3,m3).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>j1</strong> : float</p>
<blockquote>
<div><p>Total angular momentum 1.</p>
</div></blockquote>
<p><strong>j2</strong> : float</p>
<blockquote>
<div><p>Total angular momentum 2.</p>
</div></blockquote>
<p><strong>j3</strong> : float</p>
<blockquote>
<div><p>Total angular momentum 3.</p>
</div></blockquote>
<p><strong>m1</strong> : float</p>
<blockquote>
<div><p>z-component of angular momentum 1.</p>
</div></blockquote>
<p><strong>m2</strong> : float</p>
<blockquote>
<div><p>z-component of angular momentum 2.</p>
</div></blockquote>
<p><strong>m3</strong> : float</p>
<blockquote>
<div><p>z-component of angular momentum 3.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cg_coeff</strong> : float</p>
<blockquote class="last">
<div><p>Requested Clebsch-Gordan coefficient.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.utilities.convert_unit">
<tt class="descname">convert_unit</tt><big>(</big><em>value</em>, <em>orig='meV'</em>, <em>to='GHz'</em><big>)</big><a class="reference internal" href="../modules/qutip/utilities.html#convert_unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.convert_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an energy from unit <cite>orig</cite> to unit <cite>to</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>value</strong> : float / array</p>
<blockquote>
<div><p>The energy in the old unit.</p>
</div></blockquote>
<p><strong>orig</strong> : string</p>
<blockquote>
<div><p>The name of the original unit (&#8220;J&#8221;, &#8220;eV&#8221;, &#8220;meV&#8221;, &#8220;GHz&#8221;, &#8220;mK&#8221;)</p>
</div></blockquote>
<p><strong>to</strong> : string</p>
<blockquote>
<div><p>The name of the new unit (&#8220;J&#8221;, &#8220;eV&#8221;, &#8220;meV&#8221;, &#8220;GHz&#8221;, &#8220;mK&#8221;)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>value_new_unit</strong> : float / array</p>
<blockquote class="last">
<div><p>The energy in the new unit.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.fileio">
<span id="file-i-o-functions"></span><span id="functions-fileio"></span><h3>File I/O Functions<a class="headerlink" href="#module-qutip.fileio" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.fileio.file_data_read">
<tt class="descname">file_data_read</tt><big>(</big><em>filename</em>, <em>sep=None</em><big>)</big><a class="reference internal" href="../modules/qutip/fileio.html#file_data_read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.file_data_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves an array of data from the requested file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Name of file containing reqested data.</p>
</div></blockquote>
<p><strong>sep</strong> : str</p>
<blockquote>
<div><p>Seperator used to store data.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>data</strong> : array_like</p>
<blockquote class="last">
<div><p>Data from selected file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.fileio.file_data_store">
<tt class="descname">file_data_store</tt><big>(</big><em>filename</em>, <em>data</em>, <em>numtype='complex'</em>, <em>numformat='decimal'</em>, <em>sep='</em>, <em>'</em><big>)</big><a class="reference internal" href="../modules/qutip/fileio.html#file_data_store"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.file_data_store" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores a matrix of data to a file to be read by an external program.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Name of data file to be stored, including extension.</p>
</div></blockquote>
<p><strong>data: array_like</strong></p>
<blockquote>
<div><p>Data to be written to file.</p>
</div></blockquote>
<p><strong>numtype</strong> : str {&#8216;complex, &#8216;real&#8217;}</p>
<blockquote>
<div><p>Type of numerical data.</p>
</div></blockquote>
<p><strong>numformat</strong> : str {&#8216;decimal&#8217;,&#8217;exp&#8217;}</p>
<blockquote>
<div><p>Format for written data.</p>
</div></blockquote>
<p><strong>sep</strong> : str</p>
<blockquote class="last">
<div><p>Single-character field seperator.  Usually a tab, space, comma,
or semicolon.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.fileio.qload">
<tt class="descname">qload</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../modules/qutip/fileio.html#qload"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.qload" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads data file from file named &#8216;filename.qu&#8217; in current directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>name</strong> : str</p>
<blockquote>
<div><p>Name of data file to be loaded.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>qobject</strong> : instance / array_like</p>
<blockquote class="last">
<div><p>Object retrieved from requested file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.fileio.qsave">
<tt class="descname">qsave</tt><big>(</big><em>data</em>, <em>name='qutip_data'</em><big>)</big><a class="reference internal" href="../modules/qutip/fileio.html#qsave"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.qsave" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves given data to file named &#8216;filename.qu&#8217; in current directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : instance/array_like</p>
<blockquote>
<div><p>Input Python object to be stored.</p>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote class="last">
<div><p>Name of output data file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.parallel">
<span id="parallelization"></span><span id="functions-parallel"></span><h3>Parallelization<a class="headerlink" href="#module-qutip.parallel" title="Permalink to this headline">¶</a></h3>
<p>This function provides functions for parallel execution of loops and function
mappings, using the builtin Python module multiprocessing.</p>
<dl class="function">
<dt id="qutip.parallel.parfor">
<tt class="descname">parfor</tt><big>(</big><em>func</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/qutip/parallel.html#parfor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.parallel.parfor" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes a multi-variable function in parallel on the local machine.</p>
<p>Parallel execution of a for-loop over function <cite>func</cite> for multiple input
arguments and keyword arguments.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">From QuTiP 3.1.0, we recommend to use <tt class="xref py py-func docutils literal"><span class="pre">qutip.parallel_map</span></tt>
instead of this function.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>func</strong> : function_type</p>
<blockquote>
<div><p>A function to run in parallel on the local machine. The function &#8216;func&#8217;
accepts a series of arguments that are passed to the function as
variables. In general, the function can have multiple input variables,
and these arguments must be passed in the same order as they are
defined in the function definition.  In addition, the user can pass
multiple keyword arguments to the function.</p>
</div></blockquote>
<p><strong>The following keyword argument is reserved:</strong></p>
<p><strong>num_cpus</strong> : int</p>
<blockquote>
<div><p>Number of CPU&#8217;s to use.  Default uses maximum number of CPU&#8217;s.
Performance degrades if num_cpus is larger than the physical CPU
count of your machine.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : list</p>
<blockquote class="last">
<div><p>A <tt class="docutils literal"><span class="pre">list</span></tt> with length equal to number of input parameters
containing the output from <cite>func</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.parallel.parallel_map">
<tt class="descname">parallel_map</tt><big>(</big><em>task</em>, <em>values</em>, <em>task_args=()</em>, <em>task_kwargs={}</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/qutip/parallel.html#parallel_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.parallel.parallel_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel execution of a mapping of <cite>values</cite> to the function <cite>task</cite>. This
is functionally equivalent to:</p>
<blockquote>
<div>result = [task(value, <a href="#id14"><span class="problematic" id="id15">*</span></a>task_args, <a href="#id16"><span class="problematic" id="id17">**</span></a>task_kwargs) for value in values]</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>task: a Python function</strong></p>
<blockquote>
<div><p>The function that is to be called for each value in <tt class="docutils literal"><span class="pre">task_vec</span></tt>.</p>
</div></blockquote>
<p><strong>values: array / list</strong></p>
<blockquote>
<div><p>The list or array of values for which the <tt class="docutils literal"><span class="pre">task</span></tt> function is to be
evaluated.</p>
</div></blockquote>
<p><strong>task_args: list / dictionary</strong></p>
<blockquote>
<div><p>The optional additional argument to the <tt class="docutils literal"><span class="pre">task</span></tt> function.</p>
</div></blockquote>
<p><strong>task_kwargs: list / dictionary</strong></p>
<blockquote>
<div><p>The optional additional keyword argument to the <tt class="docutils literal"><span class="pre">task</span></tt> function.</p>
</div></blockquote>
<p><strong>progress_bar: ProgressBar</strong></p>
<blockquote>
<div><p>Progress bar class instance for showing progress.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : list</p>
<blockquote class="last">
<div><p>The result list contains the value of
<tt class="docutils literal"><span class="pre">task(value,</span> <span class="pre">*task_args,</span> <span class="pre">**task_kwargs)</span></tt> for each
value in <tt class="docutils literal"><span class="pre">values</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.parallel.serial_map">
<tt class="descname">serial_map</tt><big>(</big><em>task</em>, <em>values</em>, <em>task_args=()</em>, <em>task_kwargs={}</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/qutip/parallel.html#serial_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.parallel.serial_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Serial mapping function with the same call signature as parallel_map, for
easy switching between serial and parallel execution. This
is functionally equivalent to:</p>
<blockquote>
<div>result = [task(value, <a href="#id18"><span class="problematic" id="id19">*</span></a>task_args, <a href="#id20"><span class="problematic" id="id21">**</span></a>task_kwargs) for value in values]</div></blockquote>
<p>This function work as a drop-in replacement of <tt class="xref py py-func docutils literal"><span class="pre">qutip.parallel_map</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>task: a Python function</strong></p>
<blockquote>
<div><p>The function that is to be called for each value in <tt class="docutils literal"><span class="pre">task_vec</span></tt>.</p>
</div></blockquote>
<p><strong>values: array / list</strong></p>
<blockquote>
<div><p>The list or array of values for which the <tt class="docutils literal"><span class="pre">task</span></tt> function is to be
evaluated.</p>
</div></blockquote>
<p><strong>task_args: list / dictionary</strong></p>
<blockquote>
<div><p>The optional additional argument to the <tt class="docutils literal"><span class="pre">task</span></tt> function.</p>
</div></blockquote>
<p><strong>task_kwargs: list / dictionary</strong></p>
<blockquote>
<div><p>The optional additional keyword argument to the <tt class="docutils literal"><span class="pre">task</span></tt> function.</p>
</div></blockquote>
<p><strong>progress_bar: ProgressBar</strong></p>
<blockquote>
<div><p>Progress bar class instance for showing progress.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : list</p>
<blockquote class="last">
<div><p>The result list contains the value of
<tt class="docutils literal"><span class="pre">task(value,</span> <span class="pre">*task_args,</span> <span class="pre">**task_kwargs)</span></tt> for each
value in <tt class="docutils literal"><span class="pre">values</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.ipynbtools">
<span id="ipython-notebook-tools"></span><span id="functions-ipython"></span><h3>IPython Notebook Tools<a class="headerlink" href="#module-qutip.ipynbtools" title="Permalink to this headline">¶</a></h3>
<p>This module contains utility functions for using QuTiP with IPython notebooks.</p>
<dl class="function">
<dt id="qutip.ipynbtools.parfor">
<tt class="descname">parfor</tt><big>(</big><em>task</em>, <em>task_vec</em>, <em>args=None</em>, <em>client=None</em>, <em>view=None</em>, <em>show_scheduling=False</em>, <em>show_progressbar=False</em><big>)</big><a class="reference internal" href="../modules/qutip/ipynbtools.html#parfor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.ipynbtools.parfor" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the function <tt class="docutils literal"><span class="pre">tast</span></tt> for each value in <tt class="docutils literal"><span class="pre">task_vec</span></tt> using a cluster
of IPython engines. The function <tt class="docutils literal"><span class="pre">task</span></tt> should have the signature
<tt class="docutils literal"><span class="pre">task(value,</span> <span class="pre">args)</span></tt> or <tt class="docutils literal"><span class="pre">task(value)</span></tt> if <tt class="docutils literal"><span class="pre">args=None</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">client</span></tt> and <tt class="docutils literal"><span class="pre">view</span></tt> are the IPython.parallel client and
load-balanced view that will be used in the parfor execution. If these
are <tt class="docutils literal"><span class="pre">None</span></tt>, new instances will be created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>task: a Python function</strong></p>
<blockquote>
<div><p>The function that is to be called for each value in <tt class="docutils literal"><span class="pre">task_vec</span></tt>.</p>
</div></blockquote>
<p><strong>task_vec: array / list</strong></p>
<blockquote>
<div><p>The list or array of values for which the <tt class="docutils literal"><span class="pre">task</span></tt> function is to be
evaluated.</p>
</div></blockquote>
<p><strong>args: list / dictionary</strong></p>
<blockquote>
<div><p>The optional additional argument to the <tt class="docutils literal"><span class="pre">task</span></tt> function. For example
a dictionary with parameter values.</p>
</div></blockquote>
<p><strong>client: IPython.parallel.Client</strong></p>
<blockquote>
<div><p>The IPython.parallel Client instance that will be used in the
parfor execution.</p>
</div></blockquote>
<p><strong>view: a IPython.parallel.Client view</strong></p>
<blockquote>
<div><p>The view that is to be used in scheduling the tasks on the IPython
cluster. Preferably a load-balanced view, which is obtained from the
IPython.parallel.Client instance client by calling,
view = client.load_balanced_view().</p>
</div></blockquote>
<p><strong>show_scheduling: bool {False, True}, default False</strong></p>
<blockquote>
<div><p>Display a graph showing how the tasks (the evaluation of <tt class="docutils literal"><span class="pre">task</span></tt> for
for the value in <tt class="docutils literal"><span class="pre">task_vec1</span></tt>) was scheduled on the IPython engine
cluster.</p>
</div></blockquote>
<p><strong>show_progressbar: bool {False, True}, default False</strong></p>
<blockquote>
<div><p>Display a HTML-based progress bar duing the execution of the parfor
loop.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : list</p>
<blockquote class="last">
<div><p>The result list contains the value of <tt class="docutils literal"><span class="pre">task(value,</span> <span class="pre">args)</span></tt> for each
value in <tt class="docutils literal"><span class="pre">task_vec</span></tt>, that is, it should be equivalent to
<tt class="docutils literal"><span class="pre">[task(v,</span> <span class="pre">args)</span> <span class="pre">for</span> <span class="pre">v</span> <span class="pre">in</span> <span class="pre">task_vec]</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.ipynbtools.parallel_map">
<tt class="descname">parallel_map</tt><big>(</big><em>task</em>, <em>values</em>, <em>task_args=None</em>, <em>task_kwargs=None</em>, <em>client=None</em>, <em>view=None</em>, <em>progress_bar=None</em>, <em>show_scheduling=False</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/qutip/ipynbtools.html#parallel_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.ipynbtools.parallel_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the function <tt class="docutils literal"><span class="pre">task</span></tt> for each value in <tt class="docutils literal"><span class="pre">values</span></tt> using a cluster
of IPython engines. The function <tt class="docutils literal"><span class="pre">task</span></tt> should have the signature
<tt class="docutils literal"><span class="pre">task(value,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">client</span></tt> and <tt class="docutils literal"><span class="pre">view</span></tt> are the IPython.parallel client and
load-balanced view that will be used in the parfor execution. If these
are <tt class="docutils literal"><span class="pre">None</span></tt>, new instances will be created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>task: a Python function</strong></p>
<blockquote>
<div><p>The function that is to be called for each value in <tt class="docutils literal"><span class="pre">task_vec</span></tt>.</p>
</div></blockquote>
<p><strong>values: array / list</strong></p>
<blockquote>
<div><p>The list or array of values for which the <tt class="docutils literal"><span class="pre">task</span></tt> function is to be
evaluated.</p>
</div></blockquote>
<p><strong>task_args: list / dictionary</strong></p>
<blockquote>
<div><p>The optional additional argument to the <tt class="docutils literal"><span class="pre">task</span></tt> function.</p>
</div></blockquote>
<p><strong>task_kwargs: list / dictionary</strong></p>
<blockquote>
<div><p>The optional additional keyword argument to the <tt class="docutils literal"><span class="pre">task</span></tt> function.</p>
</div></blockquote>
<p><strong>client: IPython.parallel.Client</strong></p>
<blockquote>
<div><p>The IPython.parallel Client instance that will be used in the
parfor execution.</p>
</div></blockquote>
<p><strong>view: a IPython.parallel.Client view</strong></p>
<blockquote>
<div><p>The view that is to be used in scheduling the tasks on the IPython
cluster. Preferably a load-balanced view, which is obtained from the
IPython.parallel.Client instance client by calling,
view = client.load_balanced_view().</p>
</div></blockquote>
<p><strong>show_scheduling: bool {False, True}, default False</strong></p>
<blockquote>
<div><p>Display a graph showing how the tasks (the evaluation of <tt class="docutils literal"><span class="pre">task</span></tt> for
for the value in <tt class="docutils literal"><span class="pre">task_vec1</span></tt>) was scheduled on the IPython engine
cluster.</p>
</div></blockquote>
<p><strong>show_progressbar: bool {False, True}, default False</strong></p>
<blockquote>
<div><p>Display a HTML-based progress bar during the execution of the parfor
loop.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : list</p>
<blockquote class="last">
<div><p>The result list contains the value of
<tt class="docutils literal"><span class="pre">task(value,</span> <span class="pre">task_args,</span> <span class="pre">task_kwargs)</span></tt> for each
value in <tt class="docutils literal"><span class="pre">values</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.ipynbtools.version_table">
<tt class="descname">version_table</tt><big>(</big><em>verbose=False</em><big>)</big><a class="reference internal" href="../modules/qutip/ipynbtools.html#version_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.ipynbtools.version_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Print an HTML-formatted table with version numbers for QuTiP and its
dependencies. Use it in a IPython notebook to show which versions of
different packages that were used to run the notebook. This should make it
possible to reproduce the environment and the calculation later on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">version_table: string</p>
<blockquote class="last">
<div><p>Return an HTML-formatted string containing version information for
QuTiP dependencies.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip">
<span id="miscellaneous"></span><span id="functions-misc"></span><h3>Miscellaneous<a class="headerlink" href="#module-qutip" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.about">
<tt class="descname">about</tt><big>(</big><big>)</big><a class="headerlink" href="#qutip.about" title="Permalink to this definition">¶</a></dt>
<dd><p>About box for qutip. Gives version numbers for
QuTiP, NumPy, SciPy, Cython, and MatPlotLib.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.simdiag">
<tt class="descname">simdiag</tt><big>(</big><em>ops</em>, <em>evals=True</em><big>)</big><a class="headerlink" href="#qutip.simdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulateous diagonalization of communting Hermitian matrices..</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ops</strong> : list/array</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> or <tt class="docutils literal"><span class="pre">array</span></tt> of qobjs representing commuting Hermitian
operators.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eigs</strong> : tuple</p>
<blockquote class="last">
<div><p>Tuple of arrays representing eigvecs and eigvals of quantum objects
corresponding to simultaneous eigenvectors and eigenvalues for each
operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2011 and later, P.D. Nation, J.R. Johansson.<br/>
      Last updated on Dec 31, 2014.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>
